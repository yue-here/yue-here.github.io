<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A visual guide to how diffusion models work | Yue Wu</title>
<meta name=keywords content><meta name=description content="This article is aimed at those who want to understand exactly how diffusion models work, with no prior knowledge expected. I&rsquo;ve tried to use illustrations wherever possible to provide visual intuitions on each part of these models. I&rsquo;ve kept mathematical notation and equations to a minimum, and where they are necessary I&rsquo;ve tried to define and explain them as they occur.
Intro
I&rsquo;ve framed this article around three main questions:"><meta name=author content="Yue Wu"><link rel=canonical href=https://yue-here.com/posts/diffusion/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://yue-here.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yue-here.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yue-here.com/favicon-32x32.png><link rel=apple-touch-icon href=https://yue-here.com/apple-touch-icon.png><link rel=mask-icon href=https://yue-here.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yue-here.com/posts/diffusion/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.min.css integrity=sha384-veTAhWILPOotXm+kbR5uY7dRamYLJf58I7P+hJhjeuc7hsMAkJHTsPahAl0hBST0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.min.js integrity=sha384-v6mkHYHfY/4BWq54f7lQAdtIsoZZIByznQ3ZqN38OL4KCsrxo31SLlPiak7cj/Mg crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:url" content="https://yue-here.com/posts/diffusion/"><meta property="og:site_name" content="Yue Wu"><meta property="og:title" content="A visual guide to how diffusion models work"><meta property="og:description" content="This article is aimed at those who want to understand exactly how diffusion models work, with no prior knowledge expected. I’ve tried to use illustrations wherever possible to provide visual intuitions on each part of these models. I’ve kept mathematical notation and equations to a minimum, and where they are necessary I’ve tried to define and explain them as they occur.
Intro I’ve framed this article around three main questions:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-09T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="A visual guide to how diffusion models work"><meta name=twitter:description content="This article is aimed at those who want to understand exactly how diffusion models work, with no prior knowledge expected. I&rsquo;ve tried to use illustrations wherever possible to provide visual intuitions on each part of these models. I&rsquo;ve kept mathematical notation and equations to a minimum, and where they are necessary I&rsquo;ve tried to define and explain them as they occur.
Intro
I&rsquo;ve framed this article around three main questions:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yue-here.com/posts/"},{"@type":"ListItem","position":2,"name":"A visual guide to how diffusion models work","item":"https://yue-here.com/posts/diffusion/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A visual guide to how diffusion models work","name":"A visual guide to how diffusion models work","description":"This article is aimed at those who want to understand exactly how diffusion models work, with no prior knowledge expected. I\u0026rsquo;ve tried to use illustrations wherever possible to provide visual intuitions on each part of these models. I\u0026rsquo;ve kept mathematical notation and equations to a minimum, and where they are necessary I\u0026rsquo;ve tried to define and explain them as they occur.\nIntro I\u0026rsquo;ve framed this article around three main questions:\n","keywords":[],"articleBody":"This article is aimed at those who want to understand exactly how diffusion models work, with no prior knowledge expected. I’ve tried to use illustrations wherever possible to provide visual intuitions on each part of these models. I’ve kept mathematical notation and equations to a minimum, and where they are necessary I’ve tried to define and explain them as they occur.\nIntro I’ve framed this article around three main questions:\nWhat exactly is it that diffusion models learn? How and why do diffusion models work? Once you’ve trained a model, how do you get useful stuff out of it? The examples will be based on the glyffuser, a minimal text-to-image diffusion model that I previously implemented and wrote about. The architecture of this model is a standard text-to-image denoising diffusion model without any bells or whistles. It was trained to generate pictures of new “Chinese” glyphs from English definitions. Have a look at the picture below—even if you’re not familiar with Chinese writing, I hope you’ll agree that the generated glyphs look pretty similar to the real ones!\nRandom examples of glyffuser training data (left) and generated data (right).\nWhat exactly is it that diffusion models learn? Generative AI models are often said to take a big pile of data and “learn” it. For text-to-image diffusion models, the data takes the form of pairs of images and descriptive text. But what exactly is it that we want the model to learn? First, let’s forget about the text for a moment and concentrate on what we are trying to generate: the images.\nProbability distributions Broadly, we can say that we want a generative AI model to learn the underlying probability distribution of the data. What does this mean? Consider the one-dimensional normal (Gaussian) distribution below, commonly written \\(\\mathcal{N}(\\mu,\\sigma^{2})\\) and parameterized with mean \\(\\mu = 0\\) and variance \\(\\sigma^{2}=1\\). The black curve below shows the probability density function. We can sample from it: drawing values such that over a large number of samples, the set of values reflects the underlying distribution. These days, we can simply write something like x = random.gauss(0, 1) in Python to sample from the standard normal distribution, although the computational sampling process itself is non-trivial!\nValues sampled from an underlying distribution (here, the standard normal \\(\\mathcal{N}(0,1)\\)) can then be used to estimate the parameters of that distribution.\nWe could think of a set of numbers sampled from the above normal distribution as a simple dataset, like that shown as the orange histogram above. In this particular case, we can calculate the parameters of the underlying distribution using maximum likelihood estimation, i.e. by working out the mean and variance. The normal distribution estimated from the samples is shown by the dotted line above. To take some liberties with terminology, you might consider this as a simple example of “learning” an underlying probability distribution. We can also say that here we explicitly learnt the distribution, in contrast with the implicit methods that diffusion models use.\nConceptually, this is all that generative AI is doing—learning a distribution, then sampling from that distribution!\nData representations What, then, does the underlying probability distribution of a more complex dataset look like, such as that of the image dataset we want to use to train our diffusion model?\nFirst, we need to know what the representation of the data is. Generally, a machine learning (ML) model requires data inputs with a consistent representation, i.e. format. For the example above, it was simply numbers (scalars). For images, this representation is commonly a fixed-length vector.\nThe image dataset used for the glyffuser model is ~21,000 pictures of Chinese glyphs. The images are all the same size, 128 × 128 = 16384 pixels, and greyscale (single-channel color). Thus an obvious choice for the representation is a vector \\(\\mathbf{x}\\) of length 16384, where each element corresponds to the color of one pixel: \\(\\mathbf{x} = (x_{1}, x_{2}, ... , x_{16384})\\). We can call the domain of all possible images for our dataset “pixel space”.\nAn example glyph with pixel values labelled (downsampled to 32 × 32 pixels for readability).\nDataset visualization We make the assumption that our individual data samples, \\(x\\), are actually sampled from an underlying probability distribution, \\(q(x)\\), in pixel space, much as the samples from our first example were sampled from an underlying normal distribution in 1-dimensional space. Note: the notation \\(x \\sim q(x)\\) is commonly used to mean: “the random variable \\(x\\) sampled from the probability distribution \\(q(x)\\).”\nThis distribution is clearly much more complex than a Gaussian and cannot be easily parameterized — we need to learn it with a ML model, which we’ll discuss later. First, let’s try to visualize the distribution to gain a better intution.\nAs humans find it difficult to see in more than 3 dimensions, we need to reduce the dimensionality of our data. A small digression on why this works: the manifold hypothesis posits that natural datasets lie on lower dimensional manifolds embedded in a higher dimensional space—think of a line embedded in a 2-D plane, or a plane embedded in 3-D space. We can use a dimensionality reduction technique such as UMAP to project our dataset from 16384 to 2 dimensions. The 2-D projection retains a lot of structure, consistent with the idea that our data lie on a lower dimensional manifold embedded in pixel space. In our UMAP, we see two large clusters corresponding to characters in which the components are arranged either horizontally (e.g. 明) or vertically (e.g. 草)—you can confirm this on the interactive plot below!\nLet’s now use this low-dimensional UMAP dataset as a visual shorthand for our high-dimensional dataset. Remember, we assume that these individual points have been sampled from a continuous underlying probability distribution \\(q(x)\\). To get a sense of what this distribution might look like, we can apply a KDE (kernel density estimation) over the UMAP dataset. (Note: this is just an approximation for visualization purposes)\nThis gives a sense of what \\(q(x)\\) should look like: clusters of glyphs correspond to high-probability regions of the distribution. The true \\(q(x)\\) lies in 16384 dimensions—this is the distribution we want to learn with our diffusion model.\nWe showed that for a simple distribution such as the 1-D Gaussian, we could calculate the parameters (mean and variance) from our data. However, for complex distributions such as images, we need to call on ML methods. Moreover, what we will find is that for diffusion models in practice, rather than parameterizing the distribution directly, they learn it implicitly through the process of learning how to transform noise into data over many steps.\nTakeaway The aim of generative AI such as diffusion models is to learn the complex probability distributions underlying their training data and then sample from these distributions.\nHow and why do diffusion models work? Diffusion models have recently come into the spotlight as a particularly effective method for learning these probability distributions. They generate convincing images by starting from pure noise and gradually refining it. To whet your interest, have a look at the animation below that shows the denoising process generating 16 samples.\nYour browser does not support the video tag.\rIn this section we’ll only talk about the mechanics of how these models work but if you’re interested in how they arose from the broader context of generative models, have a look at the further reading section below.\nWhat is “noise”? Let’s first precisely define noise, since the term is thrown around a lot in the context of diffusion. In particular, we are talking about Gaussian noise: consider the samples we talked about in the section about probability distributions. You could think of each sample as an image of a single pixel of noise. An image that is “pure Gaussian noise”, then, is one in which each pixel value is sampled from an independent standard Gaussian distribution, \\(\\mathcal{N}(0,1)\\). For a pure noise image in the domain of our glyph dataset, this would be noise drawn from 16384 separate Gaussian distributions. You can see this in the previous animation. One thing to keep in mind is that we can choose the means of these noise distributions, i.e. center them, on specific values—the pixel values of an image, for instance.\nFor convenience, you’ll often find the noise distributions for image datasets written as a single multivariate distribution \\(\\mathcal{N}(0,I)\\) where \\(I\\) is the identity matrix, a covariance matrix with all diagonal entries equal to 1 and zeroes elsewhere. This is simply a compact notation for a set of multiple independent Gaussians - i.e. there are no correlations between the noise on different pixels. In the basic implementations of diffusion models, only uncorrelated (a.k.a. “isotropic”) noise is used. This article contains an excellent interactive introduction on multivariate Gaussians.\nDiffusion process overview Below is an adaptation of the somewhat-famous diagram from Ho et al.’s seminal paper “Denoising Diffusion Probabilistic Models” which gives an overview of the whole diffusion process:\nDiagram of the diffusion process adapted from Ho et al. 2020. The glyph 锂, meaning “lithium”, is used as a representative sample from the dataset.\nI found that there was a lot to unpack in this diagram and simply understanding what each component meant was very helpful, so let’s go through it and define everything step by step.\nWe previously used \\(x \\sim q(x)\\) to refer to our data. Here, we’ve added a subscript, \\(x_t\\), to denote timestep \\(t\\) indicating how many steps of “noising” have taken place. We refer to the samples noised a given timestep as \\(x_{t} \\sim q(x_{t})\\). \\(x_0\\) is clean data and \\(x_{T} \\sim \\mathcal{N}(0,I)\\) is pure noise.\nWe define a forward diffusion process whereby we corrupt samples with noise. This process is described by the distribution \\(q(x_{t}|x_{t-1})\\). If we could access the hypothetical reverse process \\(q(x_{t-1}|x_{t})\\), we could generate samples from noise. As we cannot access it directly because we would need to know \\(x_0\\), we use ML to learn the parameters, \\(\\theta\\), of a model of this process, \\(p_{\\theta}(x_{t-1}|x_{t})\\).\nIn the following sections we go into detail on how the forward and reverse diffusion processes work.\nForward diffusion, or “noising” Used as a verb, “noising” an image refers to applying a transformation that moves it towards pure noise by scaling down its pixel values toward 0 while adding proportional Gaussian noise. Mathematically, this transformation is a multivariate Gaussian distribution centered on the pixel values of the preceding image.\nIn the forward diffusion process, this noising distribution is written as \\(q(x_{t}|x_{t-1})\\) where the vertical bar symbol “|” is read as “given” or “conditional on”, to indicate the pixel means are passed forward from \\(q(x_{t-1})\\). At \\(t = T\\) where \\(T\\) is a large number (commonly 1000) we aim to end up with images of pure noise (which, somewhat confusingly, is also a Gaussian distribution, as discussed previously).\nThe marginal distributions \\(q(x_{t})\\) represent the distributions that have accumulated the effects of all the previous noising steps (marginalization refers to integration over all possible conditions, which recovers the unconditioned distribution).\nSince the conditional distributions are Gaussian, what about their variances? They are determined by a variance schedule that maps timesteps to variance values. Initially, an empirically determined schedule of linearly increasing values from 0.0001 to 0.02 over 1000 steps was presented in Ho et al. Later research by Nichol \u0026 Dhariwal suggested an improved cosine schedule. They state that a schedule is most effective when the rate of information destruction through noising is relatively even per step throughout the whole noising process.\nForward diffusion intuition As we encounter Gaussian distributions both as pure noise \\(q(x_T)\\) and as the noising distribution \\(q(x_{t}|x_{t-1})\\), I’ll try to draw the distinction by giving a visual intuition of the distribution for a single noising step, \\(q(x_{1}|x_{0})\\), for some arbitrary, structured 2-dimensional data:\nEach noising step \\(q(x_{t}|x_{t-1})\\) is a Gaussian distribution conditioned on the previous step.\nThe \\(q(x_{1}|x_{0})\\) distribution is Gaussian centered around around every point in \\(x_{0}\\), show in blue. Several example points \\(x_0^{(i)}\\) are picked out to illustrate this with \\(q(x_{1}|x_{0} = x_0^{(i)})\\) shown in orange.\nIn practice, the main usage of these distributions is to generate specific instances of noised samples for training (discussed further below). We can calculate the parameters of the noising distributions at any timestep \\(t\\) directly from the variance schedule as the chain of Gaussians is itself also Gaussian. This very convenient, as we don’t need to perform noising sequentially—for any given starting data \\(x_0^{(i)}\\), we can calculate the noised sample \\(x_{t}^{(i)}\\) by sampling from \\(q(x_{t}|x_{0} = x_0^{(i)})\\) directly.\nForward diffusion visualization Let’s now return to our glyph dataset (once again using the UMAP visualization as a visual shorthand). The top row of the figure below shows our dataset sampled from distributions noised to various timesteps: \\(x_{t} \\sim q(x_t)\\). As we increase the number of noising steps, you can see that the dataset begins to resemble pure Gaussian noise. The bottom row visualizes the underlying probability distribution \\(q(x_{t})\\).\nThe dataset \\(x_t\\) (above) sampled from its probability distribution \\(q(x_{t})\\) (below) at different noising timesteps.\nReverse diffusion overview It follows that if we knew the reverse distributions \\(q(x_{t-1}|x_{t})\\), we could repeatedly subtract a small amount of noise starting from a pure noise sample \\(x_{T}\\) to arrive at a data sample \\(x_{0} \\sim q(x_{0})\\). In practice, however, we cannot access these distributions without knowing \\(x_{0}\\) beforehand. Intuitively, it’s easy make a known image much noisier but given a very noisy image, it’s much harder to guess what the original image was.\nSo what are we to do? As we have a large amount of data, we can train a ML model to accurately guess the original image that any given noisy image came from. Specifically, we learn the parameters \\(\\theta\\) of a ML model that approximates the reverse noising distributions, \\(p_{\\theta}(x_{t-1}|x_{t})\\) for \\(t = 0, ..., T\\). In practice, this is embodied in a single noise prediction model that is trained over many different samples and timesteps. This allows it to denoise any given input, as shown in the figure below.\nThe ML model predicts added noise at any given timestep \\(t\\).\nNext, let’s go over how this noise prediction model is implemented and trained in practice.\nHow the model is implemented First, we define the ML model—generally a deep neural network of some sort—that will act as our noise prediction model. This is what does the heavy lifting! In practice, any ML model that inputs and outputs data of the correct size can be used; the U-net, an architecture particularly suited to learning images, is what we use here and frequently chosen in practice. More recent models also use vision transformers.\nWe use the U-net architecture (Ronneberger et al. 2015) for our ML noise prediction model. We train the model by minimizing the difference between predicted and actual noise.\nThen we run the training loop depicted in the figure above:\nWe take a random image from our dataset and noise it to a random timestep \\(t\\). (In practice, we speed things up by doing many examples in parallel!) We feed the noised image into the ML model and train it to predict the (known to us) noise in the image. We also perform timestep conditioning by feeding the model a timestep embedding, a high-dimensional unique representation of the timestep, so that the model can distinguish between timesteps. This can be a vector the same size as our image directly added to the input (see here for a discussion of how this is implemented). The model “learns” by minimizing the value of a loss function, some measure of the difference between the predicted and actual noise. The mean square error (the mean of the squares of the pixel-wise difference between the predicted and actual noise) is used in our case. Repeat until the model is well trained. Note: A neural network is essentially a function with a huge number of parameters (on the order of 106 for the glyffuser). Neural network ML models are trained by iteratively updating their parameters using backpropagation to minimize a given loss function over many training data examples. This is an excellent introduction. These parameters effectively store the network’s “knowledge”.\nA noise prediction model trained in this way eventually sees many different combinations of timesteps and data examples. The glyffuser, for example, was trained over 100 epochs (runs through the whole data set), so it saw around 2 million data samples. Through this process, the model implicity learns the reverse diffusion distributions over the entire dataset at all different timesteps. This allows the model to sample the underlying distribution \\(q(x_0)\\) by stepwise denoising starting from pure noise. Put another way, given an image noised to any given level, the model can predict how to reduce the noise based on its guess of what the original image. By doing this repeatedly, updating its guess of the original image each time, the model can transform any noise to a sample that lies in a high-probability region of the underlying data distribution.\nReverse diffusion in practice Your browser does not support the video tag.\rWe can now revisit this video of the glyffuser denoising process. Recall a large number of steps from sample to noise e.g. \\(T=1000\\) is used during training to make the noise-to-sample trajectory very easy for the model to learn, as changes between steps will be small. Does that mean we need to run 1000 denoising steps every time we want to generate a sample?\nLuckily, this is not the case. Essentially, we can run the single-step noise prediction but then rescale it to any given step, although it might not be very good if the gap is too large! This allows us to approximate the full sampling trajectory with fewer steps. The video above uses 120 steps, for instance (most implementations will allow the user to set the number of sampling steps).\nRecall that predicting the noise at a given step is equivalent to predicting the original image \\(x_0\\), and that we can access the equation for any noised image deterministically, using only the variance schedule and \\(x_0\\). Thus, we can calculate \\(x_{t-k}\\) based on any denoising step. The closer the steps are, the better the approximation will be.\nToo few steps, however, and the results become worse as the steps become too large for the model to effectively approximate the denoising trajectory. If we only use 5 sampling steps, for example, the sampled characters don’t look very convincing at all:\nYour browser does not support the video tag.\rThere is then a whole literature on more advanced sampling methods beyond what we’ve discussed so far, allowing effective sampling with much fewer steps. These often reframe the sampling as a differential equation to be solved deterministically, giving an eerie quality to the sampling videos—I’ve included one at the end if you’re interested. In production-level models, these are usually preferred over the simple method discussed here, but the basic principle of deducing the noise-to-sample trajectory is the same. A full discussion is beyond the scope of this article but see e.g. this paper and its corresponding implementation in the Hugging Face diffusers library for more information.\nAlternative intuition from score function To me, it was still not 100% clear why training the model on noise prediction generalises so well. I found that an alternative interpretation of diffusion models known as “score-based modeling” filled some of the gaps in intuition (for more information, refer to Yang Song’s definitive article on the topic.)\nThe dataset \\(x_t\\) sampled from its probability distribution \\(q(x_{t})\\) at different noising timesteps; below we add the score function \\(\\nabla_{x}\\log q(x_{t})\\).\nI try to give a visual intuition in the bottom row of the figure above: essentially, learning the noise in our diffusion model is equivalent (to a constant factor) to learning the score function, which is the gradient of the log of the probability distribution: \\(\\nabla_{x} \\log q(x)\\). As a gradient, the score function represents a vector field with vectors pointing towards the regions of highest probability density. Subtracting the noise at each step is then equivalent to moving following the directions in this vector field towards regions of high probability density.\nAs long as there is some signal, the score function effectively guides sampling, but in regions of low probability it tends towards zero as there is little to no gradient to follow. Using many steps to cover different noise levels allows us to avoid this, as we smear out the gradient field at high noise levels, allowing sampling to converge even if we start from low probability density regions of the distribution. The figure shows that as the noise level is increased, more of the domain is covered by the score function vector field.\nSummary The aim of diffusion models is learn the underlying probability distribution of a dataset and then be able to sample from it. This requires forward and reverse diffusion (noising) processes. The forward noising process takes samples from our dataset and gradually adds Gaussian noise (pushes them off the data manifold). This forward process is computationally efficient because any level of noise can be added in closed form a single step. The reverse noising process is challenging because we need to predict how to remove the noise at each step without knowing the original data point in advance. We train a ML model to do this by giving it many examples of data noised at different timesteps. Using very small steps in the forward noising process makes it easier for the model to learn to reverse these steps, as the changes are small. By applying the reverse noising process iteratively, the model refines noisy samples step by step, eventually producing a realistic data point (one that lies on the data manifold). Takeaway Diffusion models are a powerful framework for learning complex data distributions. The distributions are learnt implicitly by modelling a sequential denoising process. This process can then be used to generate samples similar to those in the training distribution.\nOnce you’ve trained a model, how do you get useful stuff out of it? Earlier uses of generative AI such as “This Person Does Not Exist” (ca. 2019) made waves simply because it was the first time most people had seen AI-generated photorealistic human faces. A generative adversarial network or “GAN” was used in that case, but the principle remains the same: the model implicitly learnt a underlying data distribution—in that case, human faces—then sampled from it. So far, our glyffuser model does a similar thing: it samples randomly from the distribution of Chinese glyphs.\nThe question then arises: can we do something more useful than just sample randomly? You’ve likely already encountered text-to-image models such as Dall-E. They are able to incorporate extra meaning from text prompts into the diffusion process - this in known as conditioning. Likewise, diffusion models for scientific scientific applications like protein (e.g. Chroma, RFdiffusion, AlphaFold3) or inorganic crystal structure generation (e.g. MatterGen) become much more useful if can be conditioned to generate samples with desirable properties such as a specific symmetry, bulk modulus, or band gap.\nConditional distributions We can consider conditioning as a way to guide the diffusion sampling process towards particular regions of our probability distribution. We mentioned conditional distributions in the context of forward diffusion. Below we show how conditioning can be thought of as reshaping a base distribution.\nA simple example of a joint probability distribution \\(p(x, y)\\) shown as a contour map and its two marginal 1-D probability distributions, \\(p(x)\\) and \\(p(y)\\). The highest points of \\(p(x, y)\\) are at \\((x1, y1)\\) and \\((x2, y2)\\). The conditional distributions \\(p(x|y=y_1)\\) and \\(p(x|y=y_2)\\) are shown overlaid on the main plot.\nConsider the figure above. Think of \\(p(x)\\) as a distribution we want to sample from (i.e. the images), and \\(p(y)\\) as being conditioning information (i.e. the text dataset). These are the marginal distributions of a joint distribution, \\(p(x,y)\\). Integrating \\(p(x,y)\\) over \\(y\\) would recover \\(p(x)\\) and vice versa.\nSampling from \\(p(x)\\), we’re equally likely to get \\(x_1\\) or \\(x_2\\). However we can condition on \\(p(y=y_1)\\) to obtain \\(p(x|y=y_1)\\). You can think of this as taking a slice through \\(p(x,y)\\) at a given value of \\(y\\). In this conditioned distribution, we are much more likely to sample at \\(x_1\\) than \\(x_2\\).\nIn practice, in order to condition on a text dataset, we need to convert the text into a numerical form. We can do this using large language model (LLM) embeddings that can be injected into the noise prediction model during training.\nEmbedding text with an LLM In the glyffuser, our conditioning information is in the form of English text definitions. We have two requirements: 1) ML models prefer fixed-length vectors as input. 2) The numerical representation of our text must understand context - if we have the words “lithium” and “element” nearby, the meaning of “element” should be understood as “chemical element” rather than “heating element”. Both of these requirements can be met by using a pre-trained LLM.\nThe diagram below shows how an LLM converts text into fixed-length vectors. The text is first tokenized (LLMs break text into tokens, small chunks of characters, as their basic unit of interaction). Each token is converted into a base embedding, which is a fixed-length vector of the size of the LLM input. These vectors are then passed through the pre-trained LLM (here we use the encoder portion of Google’s T5 model), where they are imbued with additional contextual meaning. We end up with a array of n vectors of the same length d, i.e. a (n, d) sized tensor.\nWe can convert text to a numerical embedding imbued with contextual meaning using a pre-trained LLM.\nNote: in some models, notably Dall-E, additional image-text alignment is performed using contrastive pretraining. Imagen seems to show that we can get away without doing this.\nTraining the diffusion model with text conditioning The exact method that this embedding vector is injected into the model can vary. In Google’s Imagen model, for example, the embedding tensor is pooled (combined into a single vector in the embedding dimension) and added into the data as it passes through the noise prediction model; it is also included in a different way using cross-attention (a method of learning contextual information between sequences of tokens, most famously used in the transformer models that form the basis of LLMs like ChatGPT).\nConditioning information can be added via multiple different methods but the training loss remains the same.\nIn the glyffuser, we only use cross-attention to introduce this conditioning information. While a significant architectural change is required to introduce this additional information into the model, the loss function for our noise prediction model remains exactly the same.\nTesting the conditioned diffusion model Let’s do a simple test of the fully trained conditioned diffusion model. In the figure below, we try to denoise in a single step with the text prompt “Gold”. As touched upon in our interactive UMAP, Chinese characters often contain components known as radicals which can convey sound (phonetic radicals) or meaning (semantic radicals). A common semantic radical is derived from the character meaning “gold”, “金”, and is used in characters that are in some broad sense associated with gold or metals.\nEven with a single sampling step, conditioning guides denoising towards the relevant regions of the probability distribution.\nThe figure shows that even though a single step is insufficient to approximate the denoising trajectory very well, we have moved into a region of our probability distribution with the “金” radical. This indicates that the text prompt is effectively guiding our sampling towards a region of the glyph probability distribution related to the meaning of the prompt. The animation below shows a 120 step denoising sequence for the same prompt, “Gold”. You can see that every generated glyph has either the 釒 or 钅 radical (the same radical in traditional and simplified Chinese, respectively).\nYour browser does not support the video tag.\rTakeaway Conditioning enables us to sample meaningful outputs from diffusion models.\nFurther remarks I found that with the help of tutorials and existing libraries, it was possible to implement a working diffusion model despite not having a full understanding of what was going on under the hood. I think this is a good way to start learning and highly recommend Hugging Face’s tutorial on training a simple diffusion model using their diffusers Python library (which now includes my small bugfix!).\nI’ve omitted some topics that are crucial to how production-grade diffusion models function, but are unnecessary for core understanding. One is the question of how to generate high resolution images. In our example, we did everything in pixel space, but this becomes very computationally expensive for large images. The general approach is to perform diffusion in a smaller space, then upscale it in a separate step. Methods include latent diffusion (used in Stable Diffusion) and cascaded super-resolution models (used in Imagen). Another topic is classifier-free guidance, a very elegant method for boosting the conditioning effect to give much better prompt adherence. I show the implementation in my previous post on the glyffuser and highly recommend this article if you want to learn more.\nFurther reading A non-exhaustive list of materials I found very helpful:\nJonathan Ho’s paper, Denoising Diffusion Probabilistic Models Yang Song’s article on score-based models, Generative Modeling by Estimating Gradients of the Data Distribution Calvin Luo’s article Understanding Diffusion Models: A Unified Perspective Lilian Weng’s blog post, What are diffusion models? Jeremy Howard’s course From Deep Learning Foundations to Stable Diffusion Ryan O’Connor’s tutorial MinImagen - Build Your Own Imagen Text-to-Image Model Jonathan Kernes’ article Diffusion Models Sander Dieleman’s Perspectives on diffusion and Guidance: a cheat code for diffusion models Stefano Ermon’s Stanford CS236 course Deep Generative Models Fun extras Your browser does not support the video tag.\rDiffusion sampling using the DPMSolverSDEScheduler developed by Katherine Crowson and implemented in Hugging Face diffusers.\n","wordCount":"4961","inLanguage":"en","datePublished":"2025-01-09T00:00:00Z","dateModified":"2025-01-09T00:00:00Z","author":{"@type":"Person","name":"Yue Wu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yue-here.com/posts/diffusion/"},"publisher":{"@type":"Organization","name":"Yue Wu","logo":{"@type":"ImageObject","url":"https://yue-here.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yue-here.com/ accesskey=h title="Yue Wu (Alt + H)">Yue Wu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yue-here.com/index.html title=Home><span>Home</span></a></li><li><a href=https://yue-here.com/bio/ title=Bio><span>Bio</span></a></li><li><a href=https://yue-here.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yue-here.com/research/ title=Research><span>Research</span></a></li><li><a href=https://yue-here.com/personal/ title=Personal><span>Personal</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">A visual guide to how diffusion models work</h1><div class=post-meta><span title='2025-01-09 00:00:00 +0000 UTC'>January 9, 2025</span>&nbsp;·&nbsp;24 min&nbsp;·&nbsp;4961 words&nbsp;·&nbsp;Yue Wu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#what-exactly-is-it-that-diffusion-models-learn>What exactly is it that diffusion models learn?</a><ul><li><a href=#probability-distributions>Probability distributions</a></li><li><a href=#data-representations>Data representations</a></li><li><a href=#dataset-visualization>Dataset visualization</a></li><li><a href=#takeaway>Takeaway</a></li></ul></li><li><a href=#how-and-why-do-diffusion-models-work>How and why do diffusion models work?</a><ul><li><a href=#what-is-noise>What is &ldquo;noise&rdquo;?</a></li><li><a href=#diffusion-process-overview>Diffusion process overview</a></li><li><a href=#forward-diffusion-or-noising>Forward diffusion, or &ldquo;noising&rdquo;</a></li><li><a href=#forward-diffusion-intuition>Forward diffusion intuition</a></li><li><a href=#forward-diffusion-visualization>Forward diffusion visualization</a></li><li><a href=#reverse-diffusion-overview>Reverse diffusion overview</a></li><li><a href=#how-the-model-is-implemented>How the model is implemented</a></li><li><a href=#reverse-diffusion-in-practice>Reverse diffusion in practice</a></li><li><a href=#alternative-intuition-from-score-function>Alternative intuition from score function</a></li><li><a href=#summary>Summary</a></li><li><a href=#takeaway-1>Takeaway</a></li></ul></li><li><a href=#once-youve-trained-a-model-how-do-you-get-useful-stuff-out-of-it>Once you&rsquo;ve trained a model, how do you get useful stuff out of it?</a><ul><li><a href=#conditional-distributions>Conditional distributions</a></li><li><a href=#embedding-text-with-an-llm>Embedding text with an LLM</a></li><li><a href=#training-the-diffusion-model-with-text-conditioning>Training the diffusion model with text conditioning</a></li><li><a href=#testing-the-conditioned-diffusion-model>Testing the conditioned diffusion model</a></li><li><a href=#takeaway-2>Takeaway</a></li></ul></li><li><a href=#further-remarks>Further remarks</a></li><li><a href=#further-reading>Further reading</a></li><li><a href=#fun-extras>Fun extras</a></li></ul></nav></div></details></div><div class=post-content><p>This article is aimed at those who want to understand exactly how diffusion models work, with no prior knowledge expected. I&rsquo;ve tried to use illustrations wherever possible to provide visual intuitions on each part of these models. I&rsquo;ve kept mathematical notation and equations to a minimum, and where they are necessary I&rsquo;ve tried to define and explain them as they occur.</p><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><p>I&rsquo;ve framed this article around three main questions:</p><ul><li>What exactly is it that diffusion models learn?</li><li>How and why do diffusion models work?</li><li>Once you&rsquo;ve trained a model, how do you get useful stuff out of it?</li></ul><p>The examples will be based on the <a href=/posts/glyffuser/>glyffuser</a>, a minimal text-to-image diffusion model that I previously <a href=/posts/glyffuser/>implemented and wrote about</a>. The architecture of this model is a standard text-to-image denoising diffusion model without any bells or whistles. It was trained to generate pictures of new &ldquo;Chinese&rdquo; glyphs from English definitions. Have a look at the picture below—even if you&rsquo;re not familiar with Chinese writing, I hope you&rsquo;ll agree that the generated glyphs look pretty similar to the real ones!</p><figure class=align-center><img loading=lazy src=/real_fake_data.png#center alt="Random examples of glyffuser training data (left) and generated data (right)."><figcaption><p>Random examples of glyffuser training data (left) and generated data (right).</p></figcaption></figure><h2 id=what-exactly-is-it-that-diffusion-models-learn>What exactly is it that diffusion models learn?<a hidden class=anchor aria-hidden=true href=#what-exactly-is-it-that-diffusion-models-learn>#</a></h2><p>Generative AI models are often said to take a big pile of data and &ldquo;learn&rdquo; it. For text-to-image diffusion models, the data takes the form of pairs of images and descriptive text. But what exactly is it that we want the model to learn? First, let&rsquo;s forget about the text for a moment and concentrate on what we are trying to generate: the images.</p><h3 id=probability-distributions>Probability distributions<a hidden class=anchor aria-hidden=true href=#probability-distributions>#</a></h3><p>Broadly, we can say that we want a generative AI model to learn the <em>underlying probability distribution</em> of the data. What does this mean? Consider the one-dimensional normal (Gaussian) distribution below, commonly written \(\mathcal{N}(\mu,\sigma^{2})\) and <em>parameterized</em> with mean \(\mu = 0\) and variance \(\sigma^{2}=1\). The black curve below shows the probability density function. We can <em>sample</em> from it: drawing values such that over a large number of samples, the set of values reflects the underlying distribution. These days, we can simply write something like <code>x = random.gauss(0, 1)</code> in Python to sample from the standard normal distribution, although the computational sampling process itself is non-trivial!</p><figure class=align-center><img loading=lazy src=/Gaussian.png#center alt="Values sampled from an underlying distribution (here, the standard normal \(\mathcal{N}(0,1)\)) can then be used to estimate the parameters of that distribution."><figcaption><p>Values sampled from an underlying distribution (here, the standard normal \(\mathcal{N}(0,1)\)) can then be used to estimate the parameters of that distribution.</p></figcaption></figure><p>We could think of a set of numbers sampled from the above normal distribution as a simple dataset, like that shown as the orange histogram above. In this particular case, we can calculate the parameters of the underlying distribution using <em>maximum likelihood estimation</em>, i.e. by working out the mean and variance. The normal distribution estimated from the samples is shown by the dotted line above. To take some liberties with terminology, you might consider this as a simple example of &ldquo;learning&rdquo; an underlying probability distribution. We can also say that here we <em>explicitly</em> learnt the distribution, in contrast with the <em>implicit</em> methods that diffusion models use.</p><p>Conceptually, this is all that generative AI is doing—learning a distribution, then sampling from that distribution!</p><h3 id=data-representations>Data representations<a hidden class=anchor aria-hidden=true href=#data-representations>#</a></h3><p>What, then, does the underlying probability distribution of a more complex dataset look like, such as that of the image dataset we want to use to train our diffusion model?</p><p>First, we need to know what the <em>representation</em> of the data is. Generally, a machine learning (ML) model requires data inputs with a consistent representation, i.e. format. For the example above, it was simply numbers (scalars). For images, this representation is commonly a fixed-length vector.</p><p>The image dataset used for the glyffuser model is ~21,000 pictures of Chinese glyphs. The images are all the same size, 128 × 128 = 16384 pixels, and greyscale (single-channel color). Thus an obvious choice for the representation is a vector \(\mathbf{x}\) of length 16384, where each element corresponds to the color of one pixel: \(\mathbf{x} = (x_{1}, x_{2}, ... , x_{16384})\). We can call the domain of all possible images for our dataset &ldquo;pixel space&rdquo;.</p><figure class=align-center><img loading=lazy src=/pixel_values.png#center alt="An example glyph with pixel values labelled (downsampled to 32 × 32 pixels for readability)."><figcaption><p>An example glyph with pixel values labelled (downsampled to 32 × 32 pixels for readability).</p></figcaption></figure><h3 id=dataset-visualization>Dataset visualization<a hidden class=anchor aria-hidden=true href=#dataset-visualization>#</a></h3><p>We make the assumption that our individual data samples, \(x\), are actually sampled from an underlying probability distribution, \(q(x)\), in pixel space, much as the samples from our first example were sampled from an underlying normal distribution in 1-dimensional space. Note: the notation \(x \sim q(x)\) is commonly used to mean: &ldquo;the random variable \(x\) sampled from the probability distribution \(q(x)\).&rdquo;</p><p>This distribution is clearly much more complex than a Gaussian and cannot be easily parameterized — we need to learn it with a ML model, which we&rsquo;ll discuss later. First, let&rsquo;s try to visualize the distribution to gain a better intution.</p><p>As humans find it difficult to see in more than 3 dimensions, we need to reduce the dimensionality of our data. A small digression on why this works: the <a href=https://en.wikipedia.org/wiki/Manifold_hypothesis>manifold hypothesis</a> posits that natural datasets lie on lower dimensional manifolds embedded in a higher dimensional space—think of a line embedded in a 2-D plane, or a plane embedded in 3-D space. We can use a dimensionality reduction technique such as <a href=https://umap-learn.readthedocs.io/en/latest/>UMAP</a> to project our dataset from 16384 to 2 dimensions. The 2-D projection retains a lot of structure, consistent with the idea that our data lie on a lower dimensional manifold embedded in pixel space. In our UMAP, we see two large clusters corresponding to characters in which the components are arranged either horizontally (e.g. 明) or vertically (e.g. 草)—you can confirm this on the <strong>interactive plot</strong> below!</p><p><script src=https://cdn.plot.ly/plotly-latest.min.js></script><div id=/umap.json class=plotly style=width:100%></div><script>Plotly.d3.json("/umap.json",function(e,t){Plotly.plot("/umap.json",t.data,t.layout,{responsive:!0})})</script></p><p>Let&rsquo;s now use this low-dimensional UMAP dataset as a visual shorthand for our high-dimensional dataset. Remember, we assume that these individual points have been sampled from a continuous underlying probability distribution \(q(x)\). To get a sense of what this distribution might look like, we can apply a KDE (kernel density estimation) over the UMAP dataset. (Note: this is just an approximation for visualization purposes)</p><figure class=align-center><img loading=lazy src=/manifold2PD.png#center></figure><p>This gives a sense of what \(q(x)\) should look like: clusters of glyphs correspond to high-probability regions of the distribution. The true \(q(x)\) lies in 16384 dimensions—this is the distribution we want to learn with our diffusion model.</p><p>We showed that for a simple distribution such as the 1-D Gaussian, we could calculate the parameters (mean and variance) from our data. However, for complex distributions such as images, we need to call on ML methods. Moreover, what we will find is that for diffusion models in practice, rather than parameterizing the distribution directly, they learn it <em>implicitly</em> through the process of learning how to transform noise into data over many steps.</p><h3 id=takeaway>Takeaway<a hidden class=anchor aria-hidden=true href=#takeaway>#</a></h3><p>The aim of generative AI such as diffusion models is to learn the complex probability distributions underlying their training data and then sample from these distributions.</p><h2 id=how-and-why-do-diffusion-models-work>How and why do diffusion models work?<a hidden class=anchor aria-hidden=true href=#how-and-why-do-diffusion-models-work>#</a></h2><p>Diffusion models have recently come into the spotlight as a particularly effective method for learning these probability distributions. They generate convincing images by starting from pure noise and gradually refining it. To whet your interest, have a look at the animation below that shows the denoising process generating 16 samples.</p><center><video width=80% autoplay loop muted playsinline>
<source src=/unconditional_glyffuser_denoising.mp4 type=video/mp4>Your browser does not support the video tag.</video></center><p>In this section we&rsquo;ll only talk about the mechanics of how these models work but if you&rsquo;re interested in how they arose from the broader context of generative models, have a look at the <a href=#further-reading>further reading</a> section below.</p><h3 id=what-is-noise>What is &ldquo;noise&rdquo;?<a hidden class=anchor aria-hidden=true href=#what-is-noise>#</a></h3><p>Let&rsquo;s first precisely define noise, since the term is thrown around a lot in the context of diffusion. In particular, we are talking about Gaussian noise: consider the samples we talked about in the section about <a href=#probability-distributions>probability distributions</a>. You could think of each sample as an image of a single pixel of noise. An image that is &ldquo;pure Gaussian noise&rdquo;, then, is one in which each pixel value is sampled from an independent standard Gaussian distribution, \(\mathcal{N}(0,1)\). For a pure noise image in the domain of our glyph dataset, this would be noise drawn from 16384 separate Gaussian distributions. You can see this in the previous animation. One thing to keep in mind is that we can choose the means of these noise distributions, i.e. <em>center</em> them, on specific values—the pixel values of an image, for instance.</p><p>For convenience, you&rsquo;ll often find the noise distributions for image datasets written as a single multivariate distribution \(\mathcal{N}(0,I)\) where \(I\) is the identity matrix, a covariance matrix with all diagonal entries equal to 1 and zeroes elsewhere. This is simply a compact notation for a set of multiple independent Gaussians - i.e. there are no correlations between the noise on different pixels. In the basic implementations of diffusion models, only uncorrelated (a.k.a. &ldquo;isotropic&rdquo;) noise is used. <a href=https://distill.pub/2019/visual-exploration-gaussian-processes/>This article</a> contains an excellent interactive introduction on multivariate Gaussians.</p><h3 id=diffusion-process-overview>Diffusion process overview<a hidden class=anchor aria-hidden=true href=#diffusion-process-overview>#</a></h3><p>Below is an adaptation of the somewhat-famous diagram from <a href=https://arxiv.org/abs/2006.11239>Ho <em>et al</em>.</a>&rsquo;s seminal paper &ldquo;<em>Denoising Diffusion Probabilistic Models</em>&rdquo; which gives an overview of the whole diffusion process:</p><figure class=align-center><img loading=lazy src=/diffusion_schematic.png#center alt="Diagram of the diffusion process adapted from Ho et al. 2020. The glyph 锂, meaning &ldquo;lithium&rdquo;, is used as a representative sample from the dataset."><figcaption><p>Diagram of the diffusion process adapted from <a href=https://arxiv.org/abs/2006.11239>Ho <em>et al</em>. 2020</a>. The glyph 锂, meaning &ldquo;lithium&rdquo;, is used as a representative sample from the dataset.</p></figcaption></figure><p>I found that there was a lot to unpack in this diagram and simply understanding what each component meant was very helpful, so let&rsquo;s go through it and define everything step by step.</p><p>We previously used \(x \sim q(x)\) to refer to our data. Here, we&rsquo;ve added a subscript, \(x_t\), to denote timestep \(t\) indicating how many steps of &ldquo;noising&rdquo; have taken place. We refer to the samples noised a given timestep as \(x_{t} \sim q(x_{t})\). \(x_0\) is clean data and \(x_{T} \sim \mathcal{N}(0,I)\) is pure noise.</p><p>We define a <em>forward diffusion</em> process whereby we corrupt samples with noise. This process is described by the distribution \(q(x_{t}|x_{t-1})\). If we could access the hypothetical reverse process \(q(x_{t-1}|x_{t})\), we could generate samples from noise. As we cannot access it directly because we would need to know \(x_0\), we use ML to learn the parameters, \(\theta\), of a model of this process, \(p_{\theta}(x_{t-1}|x_{t})\).</p><p>In the following sections we go into detail on how the forward and reverse diffusion processes work.</p><h3 id=forward-diffusion-or-noising>Forward diffusion, or &ldquo;noising&rdquo;<a hidden class=anchor aria-hidden=true href=#forward-diffusion-or-noising>#</a></h3><p>Used as a verb, &ldquo;noising&rdquo; an image refers to applying a transformation that moves it towards pure noise by scaling down its pixel values toward 0 while adding proportional Gaussian noise. Mathematically, this transformation is a multivariate Gaussian distribution centered on the pixel values of the preceding image.</p><p>In the forward diffusion process, this noising distribution is written as \(q(x_{t}|x_{t-1})\) where the vertical bar symbol &ldquo;|&rdquo; is read as &ldquo;given&rdquo; or &ldquo;conditional on&rdquo;, to indicate the pixel means are passed forward from \(q(x_{t-1})\). At \(t = T\) where \(T\) is a large number (commonly 1000) we aim to end up with images of pure noise (which, somewhat confusingly, is also a Gaussian distribution, as discussed <a href=#what-is-noise>previously</a>).</p><p>The <em>marginal</em> distributions \(q(x_{t})\) represent the distributions that have accumulated the effects of all the previous noising steps (<em>marginalization</em> refers to integration over all possible conditions, which recovers the unconditioned distribution).</p><p>Since the conditional distributions are Gaussian, what about their variances? They are determined by a <em>variance schedule</em> that maps timesteps to variance values. Initially, an empirically determined schedule of linearly increasing values from 0.0001 to 0.02 over 1000 steps was presented in <a href=https://arxiv.org/abs/2006.11239>Ho <em>et al</em>.</a> Later research by <a href=https://arxiv.org/pdf/2102.09672>Nichol & Dhariwal</a> suggested an improved cosine schedule. They state that a schedule is most effective when the rate of information destruction through noising is relatively even per step throughout the whole noising process.</p><h3 id=forward-diffusion-intuition>Forward diffusion intuition<a hidden class=anchor aria-hidden=true href=#forward-diffusion-intuition>#</a></h3><p>As we encounter Gaussian distributions both as pure noise \(q(x_T)\) and as the noising distribution \(q(x_{t}|x_{t-1})\), I&rsquo;ll try to draw the distinction by giving a visual intuition of the distribution for a single noising step, \(q(x_{1}|x_{0})\), for some arbitrary, structured 2-dimensional data:</p><figure class=align-center><img loading=lazy src=/noising_distribution.png#center alt="Each noising step \(q(x_{t}|x_{t-1})\) is a Gaussian distribution conditioned on the previous step."><figcaption><p>Each noising step \(q(x_{t}|x_{t-1})\) is a Gaussian distribution conditioned on the previous step.</p></figcaption></figure><p>The \(q(x_{1}|x_{0})\) distribution is Gaussian centered around around every point in \(x_{0}\), show in blue. Several example points \(x_0^{(i)}\) are picked out to illustrate this with \(q(x_{1}|x_{0} = x_0^{(i)})\) shown in orange.</p><p>In practice, the main usage of these distributions is to generate specific instances of noised samples for training (discussed further <a href=#how-the-model-is-implemented>below</a>). We can calculate the parameters of the noising distributions at any timestep \(t\) directly from the variance schedule as the chain of Gaussians is itself also Gaussian. This very convenient, as we don&rsquo;t need to perform noising sequentially—for any given starting data \(x_0^{(i)}\), we can calculate the noised sample \(x_{t}^{(i)}\) by sampling from \(q(x_{t}|x_{0} = x_0^{(i)})\) directly.</p><h3 id=forward-diffusion-visualization>Forward diffusion visualization<a hidden class=anchor aria-hidden=true href=#forward-diffusion-visualization>#</a></h3><p>Let&rsquo;s now return to our glyph dataset (once again using the <a href=#dataset-visualization>UMAP visualization</a> as a visual shorthand). The top row of the figure below shows our dataset sampled from distributions noised to various timesteps: \(x_{t} \sim q(x_t)\). As we increase the number of noising steps, you can see that the dataset begins to resemble pure Gaussian noise. The bottom row visualizes the underlying probability distribution \(q(x_{t})\).</p><figure class=align-center><img loading=lazy src=/noised_PD_only.png#center alt="The dataset \(x_t\) (above) sampled from its probability distribution \(q(x_{t})\) (below) at different noising timesteps."><figcaption><p>The dataset \(x_t\) (above) sampled from its probability distribution \(q(x_{t})\) (below) at different noising timesteps.</p></figcaption></figure><h3 id=reverse-diffusion-overview>Reverse diffusion overview<a hidden class=anchor aria-hidden=true href=#reverse-diffusion-overview>#</a></h3><p>It follows that if we knew the reverse distributions \(q(x_{t-1}|x_{t})\), we could repeatedly subtract a small amount of noise starting from a pure noise sample \(x_{T}\) to arrive at a data sample \(x_{0} \sim q(x_{0})\). In practice, however, we cannot access these distributions without knowing \(x_{0}\) beforehand. Intuitively, it&rsquo;s easy make a known image much noisier but given a very noisy image, it&rsquo;s much harder to guess what the original image was.</p><p>So what are we to do? As we have a large amount of data, we can train a ML model to accurately guess the original image that any given noisy image came from. Specifically, we learn the parameters \(\theta\) of a ML model that approximates the reverse noising distributions, \(p_{\theta}(x_{t-1}|x_{t})\) for \(t = 0, ..., T\). In practice, this is embodied in a single <em>noise prediction model</em> that is trained over many different samples and timesteps. This allows it to denoise any given input, as shown in the figure below.</p><figure class=align-center><img loading=lazy src=/noise_prediction.png#center alt="The ML model predicts added noise at any given timestep \(t\)."><figcaption><p>The ML model predicts added noise at any given timestep \(t\).</p></figcaption></figure><p>Next, let&rsquo;s go over how this noise prediction model is implemented and trained in practice.</p><h3 id=how-the-model-is-implemented>How the model is implemented<a hidden class=anchor aria-hidden=true href=#how-the-model-is-implemented>#</a></h3><p>First, we define the ML model—generally a deep neural network of some sort—that will act as our noise prediction model. This is what does the heavy lifting! In practice, any ML model that inputs and outputs data of the correct size can be used; the <a href=https://arxiv.org/abs/1505.04597>U-net</a>, an architecture particularly suited to learning images, is what we use here and frequently chosen in practice. More recent models also use <em><a href=https://arxiv.org/pdf/2212.09748>vision transformers</a></em>.</p><figure class=align-center><img loading=lazy src=/unet_model.png#center alt="We use the U-net architecture (Ronneberger et al. 2015) for our ML noise prediction model. We train the model by minimizing the difference between predicted and actual noise."><figcaption><p>We use the U-net architecture (<a href=https://arxiv.org/abs/1505.04597>Ronneberger <em>et al</em>. 2015</a>) for our ML noise prediction model. We train the model by minimizing the difference between predicted and actual noise.</p></figcaption></figure><p>Then we run the training loop depicted in the figure above:</p><ul><li>We take a random image from our dataset and noise it to a random timestep \(t\). (In practice, we speed things up by doing many examples in parallel!)</li><li>We feed the noised image into the ML model and train it to predict the (known to us) noise in the image. We also perform <em>timestep conditioning</em> by feeding the model a <em>timestep embedding</em>, a high-dimensional unique representation of the timestep, so that the model can distinguish between timesteps. This can be a vector the same size as our image directly added to the input (see <a href=https://www.assemblyai.com/blog/how-imagen-actually-works/>here</a> for a discussion of how this is implemented).</li><li>The model &ldquo;learns&rdquo; by minimizing the value of a <em>loss function</em>, some measure of the difference between the predicted and actual noise. The mean square error (the mean of the squares of the pixel-wise difference between the predicted and actual noise) is used in our case.</li><li>Repeat until the model is well trained.</li></ul><p>Note: A neural network is essentially a function with a huge number of parameters (on the order of 10<sup>6</sup> for the glyffuser). Neural network ML models are trained by iteratively updating their parameters using <em>backpropagation</em> to minimize a given loss function over many training data examples. <a href=https://www.3blue1brown.com/topics/neural-networks>This</a> is an excellent introduction. These parameters effectively store the network&rsquo;s &ldquo;knowledge&rdquo;.</p><p>A noise prediction model trained in this way eventually sees many different combinations of timesteps and data examples. The glyffuser, for example, was trained over 100 <em>epochs</em> (runs through the whole data set), so it saw around 2 million data samples. Through this process, the model implicity learns the reverse diffusion distributions over the entire dataset at all different timesteps. This allows the model to sample the underlying distribution \(q(x_0)\) by stepwise denoising starting from pure noise. Put another way, given an image noised to any given level, the model can predict how to reduce the noise based on its guess of what the original image. By doing this repeatedly, updating its guess of the original image each time, the model can transform any noise to a sample that lies in a high-probability region of the underlying data distribution.</p><h3 id=reverse-diffusion-in-practice>Reverse diffusion in practice<a hidden class=anchor aria-hidden=true href=#reverse-diffusion-in-practice>#</a></h3><center><video width=80% autoplay loop muted playsinline>
<source src=/unconditional_glyffuser_denoising.mp4 type=video/mp4>Your browser does not support the video tag.</video></center><p>We can now revisit this video of the glyffuser denoising process. Recall a large number of steps from sample to noise e.g. \(T=1000\) is used during training to make the noise-to-sample trajectory very easy for the model to learn, as changes between steps will be small. Does that mean we need to run 1000 denoising steps every time we want to generate a sample?</p><p>Luckily, this is not the case. Essentially, we can run the single-step noise prediction but then rescale it to any given step, although it might not be very good if the gap is too large! This allows us to approximate the full sampling trajectory with fewer steps. The video above uses 120 steps, for instance (most implementations will allow the user to set the number of sampling steps).</p><p><a href=#reverse-diffusion-overview>Recall</a> that predicting the noise at a given step is equivalent to predicting the original image \(x_0\), and that we can access the equation for any noised image deterministically, using only the variance schedule and \(x_0\). Thus, we can calculate \(x_{t-k}\) based on any denoising step. The closer the steps are, the better the approximation will be.</p><p>Too few steps, however, and the results become worse as the steps become too large for the model to effectively approximate the denoising trajectory. If we only use 5 sampling steps, for example, the sampled characters don&rsquo;t look very convincing at all:</p><center><video width=80% autoplay loop muted playsinline>
<source src=/uncon_denoising_5step.mp4 type=video/mp4>Your browser does not support the video tag.</video></center><p>There is then a whole literature on more advanced sampling methods beyond what we&rsquo;ve discussed so far, allowing effective sampling with much fewer steps. These often reframe the sampling as a differential equation to be solved deterministically, giving an eerie quality to the sampling videos—I&rsquo;ve included one at the <a href=#fun-extras>end</a> if you&rsquo;re interested. In production-level models, these are usually preferred over the simple method discussed here, but the basic principle of deducing the noise-to-sample trajectory is the same. A full discussion is beyond the scope of this article but see e.g. <a href=https://arxiv.org/abs/2206.00364>this paper</a> and its corresponding <a href=https://huggingface.co/docs/diffusers/en/api/schedulers/overview>implementation</a> in the Hugging Face <code>diffusers</code> library for more information.</p><h3 id=alternative-intuition-from-score-function>Alternative intuition from score function<a hidden class=anchor aria-hidden=true href=#alternative-intuition-from-score-function>#</a></h3><p>To me, it was still not 100% clear why training the model on noise prediction generalises so well. I found that an alternative interpretation of diffusion models known as &ldquo;score-based modeling&rdquo; filled some of the gaps in intuition (for more information, refer to Yang Song&rsquo;s <a href=https://yang-song.net/blog/2021/score/>definitive article</a> on the topic.)</p><figure class=align-center><img loading=lazy src=/noised_PD_scorefunction.png#center alt="The dataset \(x_t\) sampled from its probability distribution \(q(x_{t})\) at different noising timesteps; below we add the score function \(\nabla_{x}\log q(x_{t})\)."><figcaption><p>The dataset \(x_t\) sampled from its probability distribution \(q(x_{t})\) at different noising timesteps; below we add the score function \(\nabla_{x}\log q(x_{t})\).</p></figcaption></figure><p>I try to give a visual intuition in the bottom row of the figure above: essentially, learning the noise in our diffusion model is <a href=https://calvinyluo.com/2022/08/26/diffusion-tutorial.html>equivalent</a> (to a constant factor) to learning the <em>score function</em>, which is the gradient of the log of the probability distribution: \(\nabla_{x} \log q(x)\). As a gradient, the score function represents a vector field with vectors pointing towards the regions of highest probability density. Subtracting the noise at each step is then equivalent to moving following the directions in this vector field towards regions of high probability density.</p><p>As long as there is some signal, the score function effectively guides sampling, but in regions of low probability it tends towards zero as there is little to no gradient to follow. Using many steps to cover different noise levels allows us to avoid this, as we smear out the gradient field at high noise levels, allowing sampling to converge even if we start from low probability density regions of the distribution. The figure shows that as the noise level is increased, more of the domain is covered by the score function vector field.</p><h3 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h3><ul><li>The aim of diffusion models is learn the underlying probability distribution of a dataset and then be able to sample from it. This requires forward and reverse diffusion (noising) processes.</li><li>The forward noising process takes samples from our dataset and gradually adds Gaussian noise (pushes them off the data manifold). This forward process is computationally efficient because any level of noise can be added in closed form a single step.</li><li>The reverse noising process is challenging because we need to predict how to remove the noise at each step without knowing the original data point in advance. We train a ML model to do this by giving it many examples of data noised at different timesteps.</li><li>Using very small steps in the forward noising process makes it easier for the model to learn to reverse these steps, as the changes are small.</li><li>By applying the reverse noising process iteratively, the model refines noisy samples step by step, eventually producing a realistic data point (one that lies on the data manifold).</li></ul><h3 id=takeaway-1>Takeaway<a hidden class=anchor aria-hidden=true href=#takeaway-1>#</a></h3><p>Diffusion models are a powerful framework for learning complex data distributions. The distributions are learnt implicitly by modelling a sequential denoising process. This process can then be used to generate samples similar to those in the training distribution.</p><h2 id=once-youve-trained-a-model-how-do-you-get-useful-stuff-out-of-it>Once you&rsquo;ve trained a model, how do you get useful stuff out of it?<a hidden class=anchor aria-hidden=true href=#once-youve-trained-a-model-how-do-you-get-useful-stuff-out-of-it>#</a></h2><p>Earlier uses of generative AI such as &ldquo;<a href=https://thispersondoesnotexist.com/>This Person Does Not Exist</a>&rdquo; (<em>ca</em>. 2019) made waves simply because it was the first time most people had seen AI-generated photorealistic human faces. A generative adversarial network or &ldquo;GAN&rdquo; was used in that case, but the principle remains the same: the model implicitly learnt a underlying data distribution—in that case, human faces—then sampled from it. So far, our glyffuser model does a similar thing: it samples randomly from the distribution of Chinese glyphs.</p><p>The question then arises: can we do something more useful than just sample randomly? You&rsquo;ve likely already encountered text-to-image models such as Dall-E. They are able to incorporate extra meaning from text prompts into the diffusion process - this in known as <em>conditioning</em>. Likewise, diffusion models for scientific scientific applications like protein (e.g. <a href=https://github.com/generatebio/chroma>Chroma</a>, <a href=https://github.com/RosettaCommons/RFdiffusion>RFdiffusion</a>, <a href=https://github.com/google-deepmind/alphafold3>AlphaFold3</a>) or inorganic crystal structure generation (e.g. <a href=https://arxiv.org/abs/2312.03687>MatterGen</a>) become much more useful if can be conditioned to generate samples with desirable properties such as a specific symmetry, bulk modulus, or band gap.</p><h3 id=conditional-distributions>Conditional distributions<a hidden class=anchor aria-hidden=true href=#conditional-distributions>#</a></h3><p>We can consider conditioning as a way to guide the diffusion sampling process towards particular regions of our probability distribution. We mentioned conditional distributions <a href=#forward-diffusion-intuition>in the context of forward diffusion</a>. Below we show how conditioning can be thought of as reshaping a base distribution.</p><figure class=align-center><img loading=lazy src=/conditional_distributions.png#center alt="A simple example of a joint probability distribution \(p(x, y)\) shown as a contour map and its two marginal 1-D probability distributions, \(p(x)\) and \(p(y)\). The highest points of \(p(x, y)\) are at \((x1, y1)\) and \((x2, y2)\). The conditional distributions \(p(x|y=y_1)\) and \(p(x|y=y_2)\) are shown overlaid on the main plot."><figcaption><p>A simple example of a joint probability distribution \(p(x, y)\) shown as a contour map and its two marginal 1-D probability distributions, \(p(x)\) and \(p(y)\). The highest points of \(p(x, y)\) are at \((x1, y1)\) and \((x2, y2)\). The conditional distributions \(p(x|y=y_1)\) and \(p(x|y=y_2)\) are shown overlaid on the main plot.</p></figcaption></figure><p>Consider the figure above. Think of \(p(x)\) as a distribution we want to sample from (i.e. the images), and \(p(y)\) as being conditioning information (i.e. the text dataset). These are the <em>marginal distributions</em> of a <em>joint distribution</em>, \(p(x,y)\). Integrating \(p(x,y)\) over \(y\) would recover \(p(x)\) and vice versa.</p><p>Sampling from \(p(x)\), we&rsquo;re equally likely to get \(x_1\) or \(x_2\). However we can condition on \(p(y=y_1)\) to obtain \(p(x|y=y_1)\). You can think of this as taking a slice through \(p(x,y)\) at a given value of \(y\). In this conditioned distribution, we are much more likely to sample at \(x_1\) than \(x_2\).</p><p>In practice, in order to condition on a text dataset, we need to convert the text into a numerical form. We can do this using <em>large language model (LLM) embeddings</em> that can be injected into the noise prediction model during training.</p><h3 id=embedding-text-with-an-llm>Embedding text with an LLM<a hidden class=anchor aria-hidden=true href=#embedding-text-with-an-llm>#</a></h3><p>In the glyffuser, our conditioning information is in the form of <a href=https://github.com/unicode-org/unihan-database/blob/main/kDefinition.txt>English text definitions</a>. We have two requirements: 1) ML models prefer fixed-length vectors as input. 2) The numerical representation of our text must understand context - if we have the words &ldquo;lithium&rdquo; and &ldquo;element&rdquo; nearby, the meaning of &ldquo;element&rdquo; should be understood as &ldquo;chemical element&rdquo; rather than &ldquo;heating element&rdquo;. Both of these requirements can be met by using a pre-trained LLM.</p><p>The diagram below shows how an LLM converts text into fixed-length vectors. The text is first <em>tokenized</em> (LLMs break text into <em>tokens</em>, small chunks of characters, as their basic unit of interaction). Each token is converted into a base <em>embedding</em>, which is a fixed-length vector of the size of the LLM input. These vectors are then passed through the pre-trained LLM (here we use the <em>encoder</em> portion of Google&rsquo;s T5 model), where they are imbued with additional contextual meaning. We end up with a array of <em>n</em> vectors of the same length <em>d</em>, i.e. a (<em>n, d</em>) sized tensor.</p><figure class=align-center><img loading=lazy src=/LLM_embedding.png#center alt="We can convert text to a numerical embedding imbued with contextual meaning using a pre-trained LLM."><figcaption><p>We can convert text to a numerical embedding imbued with contextual meaning using a pre-trained LLM.</p></figcaption></figure><p>Note: in some models, notably Dall-E, additional image-text alignment is performed using <em><a href=https://arxiv.org/abs/2112.10741>contrastive pretraining</a></em>. <a href=https://arxiv.org/abs/2205.11487>Imagen</a> seems to show that we can get away without doing this.</p><h3 id=training-the-diffusion-model-with-text-conditioning>Training the diffusion model with text conditioning<a hidden class=anchor aria-hidden=true href=#training-the-diffusion-model-with-text-conditioning>#</a></h3><p>The exact method that this embedding vector is injected into the model can vary. In Google&rsquo;s <a href=https://arxiv.org/pdf/2205.11487>Imagen</a> model, for example, the embedding tensor is pooled (combined into a single vector in the embedding dimension) and added into the data as it passes through the noise prediction model; it is also included in a different way using <em>cross-attention</em> (a method of learning contextual information between sequences of tokens, most famously used in the <em>transformer</em> models that form the basis of LLMs like ChatGPT).</p><figure class=align-center><img loading=lazy src=/text_conditioning.png#center alt="Conditioning information can be added via multiple different methods but the training loss remains the same."><figcaption><p>Conditioning information can be added <em>via</em> multiple different methods but the training loss remains the same.</p></figcaption></figure><p>In the glyffuser, we only use cross-attention to introduce this conditioning information. While a significant architectural change is required to introduce this additional information into the model, the loss function for our noise prediction model remains exactly the same.</p><h3 id=testing-the-conditioned-diffusion-model>Testing the conditioned diffusion model<a hidden class=anchor aria-hidden=true href=#testing-the-conditioned-diffusion-model>#</a></h3><p>Let&rsquo;s do a simple test of the fully trained conditioned diffusion model. In the figure below, we try to denoise in a single step with the text prompt &ldquo;Gold&rdquo;. As touched upon in our <a href=#dataset-visualization>interactive UMAP</a>, Chinese characters often contain components known as <em>radicals</em> which can convey sound (phonetic radicals) or meaning (semantic radicals). A common semantic radical is derived from the character meaning &ldquo;gold&rdquo;, &ldquo;金&rdquo;, and is used in characters that are in some broad sense associated with gold or metals.</p><figure class=align-center><img loading=lazy src=/conditioned_denoising.png#center alt="Even with a single sampling step, conditioning guides denoising towards the relevant regions of the probability distribution."><figcaption><p>Even with a single sampling step, conditioning guides denoising towards the relevant regions of the probability distribution.</p></figcaption></figure><p>The figure shows that even though a single step is insufficient to approximate the denoising trajectory very well, we have moved into a region of our probability distribution with the &ldquo;金&rdquo; radical. This indicates that the text prompt is effectively guiding our sampling towards a region of the glyph probability distribution related to the meaning of the prompt. The animation below shows a 120 step denoising sequence for the same prompt, &ldquo;Gold&rdquo;. You can see that every generated glyph has either the 釒 or 钅 radical (the same radical in traditional and simplified Chinese, respectively).</p><center><video width=80% autoplay loop muted playsinline>
<source src=/cond_denoising_gold.mp4 type=video/mp4>Your browser does not support the video tag.</video></center><h3 id=takeaway-2>Takeaway<a hidden class=anchor aria-hidden=true href=#takeaway-2>#</a></h3><p>Conditioning enables us to sample meaningful outputs from diffusion models.</p><h2 id=further-remarks>Further remarks<a hidden class=anchor aria-hidden=true href=#further-remarks>#</a></h2><p>I found that with the help of tutorials and existing libraries, it was possible to implement a working diffusion model despite not having a full understanding of what was going on under the hood. I think this is a good way to start learning and highly recommend Hugging Face&rsquo;s <a href=https://huggingface.co/docs/diffusers/tutorials/basic_training>tutorial</a> on training a simple diffusion model using their <code>diffusers</code> Python library (which now includes my small <a href=https://github.com/huggingface/diffusers/pull/8223>bugfix</a>!).</p><p>I&rsquo;ve omitted some topics that are crucial to how production-grade diffusion models function, but are unnecessary for core understanding. One is the question of how to generate high resolution images. In our example, we did everything in pixel space, but this becomes very computationally expensive for large images. The general approach is to perform diffusion in a smaller space, then upscale it in a separate step. Methods include latent diffusion (used in Stable Diffusion) and cascaded super-resolution models (used in Imagen). Another topic is classifier-free guidance, a very elegant method for boosting the conditioning effect to give much better prompt adherence. I show the implementation in my previous post on the <a href=/posts/glyffuser/>glyffuser</a> and highly recommend <a href=https://sander.ai/2022/05/26/guidance.html>this article</a> if you want to learn more.</p><h2 id=further-reading>Further reading<a hidden class=anchor aria-hidden=true href=#further-reading>#</a></h2><p>A non-exhaustive list of materials I found very helpful:</p><ul><li>Jonathan Ho&rsquo;s paper, <a href=https://arxiv.org/abs/2006.11239><em>Denoising Diffusion Probabilistic Models</em></a></li><li>Yang Song&rsquo;s article on score-based models, <a href=https://yang-song.net/blog/2021/score/><em>Generative Modeling by Estimating Gradients of the Data Distribution</em></a></li><li>Calvin Luo&rsquo;s article <a href=https://calvinyluo.com/2022/08/26/diffusion-tutorial.html><em>Understanding Diffusion Models: A Unified Perspective</em></a></li><li>Lilian Weng&rsquo;s blog post, <a href=https://lilianweng.github.io/posts/2021-07-11-diffusion-models/><em>What are diffusion models?</em></a></li><li>Jeremy Howard&rsquo;s course <a href=https://course.fast.ai/Lessons/part2.html><em>From Deep Learning Foundations to Stable Diffusion</em></a></li><li>Ryan O&rsquo;Connor&rsquo;s tutorial <a href=https://www.assemblyai.com/blog/minimagen-build-your-own-imagen-text-to-image-model/><em>MinImagen - Build Your Own Imagen Text-to-Image Model</em></a></li><li>Jonathan Kernes&rsquo; article <a href=https://towardsdatascience.com/diffusion-models-91b75430ec2><em>Diffusion Models</em></a></li><li>Sander Dieleman&rsquo;s <a href=https://sander.ai/2023/07/20/perspectives.html><em>Perspectives on diffusion</em></a> and <a href=https://sander.ai/2022/05/26/guidance.html><em>Guidance: a cheat code for diffusion models</em></a></li><li>Stefano Ermon&rsquo;s Stanford CS236 course <a href=https://deepgenerativemodels.github.io/><em>Deep Generative Models</em></a></li></ul><h2 id=fun-extras>Fun extras<a hidden class=anchor aria-hidden=true href=#fun-extras>#</a></h2><center><video width=80% autoplay loop muted playsinline>
<source src=/ODE_sampling.mp4 type=video/mp4>Your browser does not support the video tag.</video></center><p>Diffusion sampling using the <a href=https://huggingface.co/docs/diffusers/main/en/api/schedulers/dpm_sde/><code>DPMSolverSDEScheduler</code></a> developed by <a href=https://github.com/crowsonkb/>Katherine Crowson</a> and implemented in Hugging Face <code>diffusers</code>.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://yue-here.com/posts/dpo/><span class=title>« Prev</span><br><span>Using human feedback to align a diffusion model with DPO</span>
</a><a class=next href=https://yue-here.com/posts/glyffuser/><span class=title>Next »</span><br><span>Teaching an AI to invent new Chinese characters</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yue-here.com/>Yue Wu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>