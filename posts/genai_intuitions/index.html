<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A visual guide to how diffusion models work | Yue Wu</title>
<meta name=keywords content><meta name=description content="This is an article for those who want to understand exactly what is going on in diffusion models, with no prior knowledge expected. Illustrations are used to provide visual intuitions on how each component of these models work. Any notation and equations are defined and explained clearly.
Intro
Diffusion models are one of the generative AI models du jour, being the core technology behind almost all popular text-to-image applications used today (see e.g. Dall-E, Stable Diffusion, Midjourney, Imagen). They are also seeing increasing usage in scientific fields such as my own area of materials science."><meta name=author content="Yue Wu"><link rel=canonical href=https://yue-here.com/posts/genai_intuitions/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://yue-here.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yue-here.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yue-here.com/favicon-32x32.png><link rel=apple-touch-icon href=https://yue-here.com/apple-touch-icon.png><link rel=mask-icon href=https://yue-here.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yue-here.com/posts/genai_intuitions/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.min.css integrity=sha384-veTAhWILPOotXm+kbR5uY7dRamYLJf58I7P+hJhjeuc7hsMAkJHTsPahAl0hBST0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.min.js integrity=sha384-v6mkHYHfY/4BWq54f7lQAdtIsoZZIByznQ3ZqN38OL4KCsrxo31SLlPiak7cj/Mg crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:url" content="https://yue-here.com/posts/genai_intuitions/"><meta property="og:site_name" content="Yue Wu"><meta property="og:title" content="A visual guide to how diffusion models work"><meta property="og:description" content="This is an article for those who want to understand exactly what is going on in diffusion models, with no prior knowledge expected. Illustrations are used to provide visual intuitions on how each component of these models work. Any notation and equations are defined and explained clearly.
Intro Diffusion models are one of the generative AI models du jour, being the core technology behind almost all popular text-to-image applications used today (see e.g. Dall-E, Stable Diffusion, Midjourney, Imagen). They are also seeing increasing usage in scientific fields such as my own area of materials science."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-18T00:00:00+00:00"><meta property="article:modified_time" content="2024-12-18T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="A visual guide to how diffusion models work"><meta name=twitter:description content="This is an article for those who want to understand exactly what is going on in diffusion models, with no prior knowledge expected. Illustrations are used to provide visual intuitions on how each component of these models work. Any notation and equations are defined and explained clearly.
Intro
Diffusion models are one of the generative AI models du jour, being the core technology behind almost all popular text-to-image applications used today (see e.g. Dall-E, Stable Diffusion, Midjourney, Imagen). They are also seeing increasing usage in scientific fields such as my own area of materials science."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yue-here.com/posts/"},{"@type":"ListItem","position":2,"name":"A visual guide to how diffusion models work","item":"https://yue-here.com/posts/genai_intuitions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A visual guide to how diffusion models work","name":"A visual guide to how diffusion models work","description":"This is an article for those who want to understand exactly what is going on in diffusion models, with no prior knowledge expected. Illustrations are used to provide visual intuitions on how each component of these models work. Any notation and equations are defined and explained clearly.\nIntro Diffusion models are one of the generative AI models du jour, being the core technology behind almost all popular text-to-image applications used today (see e.g. Dall-E, Stable Diffusion, Midjourney, Imagen). They are also seeing increasing usage in scientific fields such as my own area of materials science.\n","keywords":[],"articleBody":"This is an article for those who want to understand exactly what is going on in diffusion models, with no prior knowledge expected. Illustrations are used to provide visual intuitions on how each component of these models work. Any notation and equations are defined and explained clearly.\nIntro Diffusion models are one of the generative AI models du jour, being the core technology behind almost all popular text-to-image applications used today (see e.g. Dall-E, Stable Diffusion, Midjourney, Imagen). They are also seeing increasing usage in scientific fields such as my own area of materials science.\nI recently had to give a talk on diffusion models, which led me to examine my own understanding. It turns out that they have a surprising amount of detail under the hood. There are many excellent explainer articles on the subject, but I found it took me a while to understand them at a deep level due to the large amount of assumed knowledge required.\nI’ve tried to write the article I wish I had when I started trying to understand how diffusion works. This may be the article for you if you have a similar background to me - a STEM background and some coding experience, a bit rusty on the maths and stats. I aim to explain the intuitions behind how diffusion models work in a concrete way without sacrificing technical detail, but using minimal jargon and equations. When technical terms are necessary, I’ve tried to clearly define them and bootstrap any mathematical notation within the article.\nI’ve framed this article around three main questions:\nWhat exactly is it that diffusion models learn? How and why do diffusion models work? Once you’ve trained a model, how do you get useful stuff out of it? The examples will be based on the glyffuser, a minimal text-to-image diffusion model that I previously implemented and wrote about. The basic architecture of this model is a standard text-to-image denoising diffusion model, which is trained specifically to generate pictures of new “Chinese” glyphs from English definitions. This is a small but complete example of a diffusion model is useful for building intuition.\nWhat exactly is it that diffusion models learn? Generative AI models are often said to take a big pile of data and “learn” it. For text-to-image diffusion models the data takes the form of pairs of images and descriptive text. But what exactly is it that the model learns? First, let’s forget about the text component for a moment and concentrate on the images.\nProbability distributions Generally, the purpose of any generative AI model is to learn the underlying probability distribution of the data. What does this mean? Consider the one-dimensional normal (Gaussian) distribution below, commonly written \\(\\mathcal{N}(\\mu,\\sigma^{2})\\) with mean \\(\\mu = 0\\) and variance \\(\\sigma^{2}=1\\). The curve shows the probability density function. This distribution is parameterized by the mean and the variance, and we can easily sample from it computationally, e.g. with x = random.gauss(0, 1) in Python (although the computational sampling process itself is non-trivial).\nValues sampled from an underlying distribution (here, the standard normal \\(\\mathcal{N}(0,1)\\)) can then be used to estimate the parameters of that distribution.\nWe could think of a set of numbers sampled from this normal distribution as a simple dataset, like that shown as the orange histogram above. In this particular case, we can calculate the parameters of the underlying distribution using maximum likelihood estimation, i.e. by working out the mean and variance. The normal distribution estimated from the dataset of 1000 samples is shown by the dotted line above. To take some liberties with terminology, you might consider this as a simple example of “learning” an underlying probability distribution. We can also say it explicitly learnt the distribution, in contrast with the implicit methods that diffusion models use.\nData representations What, then, does the underlying probability distribution of a more complex dataset look like, such as image dataset we want to use to train our diffusion model?\nFirst, we need to know what the representation of the data is. Generally, a machine learning (ML) model requires data inputs with a consistent representation, i.e. format. For the example above, it was simply numbers (scalars). For images, this representation is commonly a fixed-length vector.\nThe image dataset used for the glyffuser model is ~21,000 pictures of Chinese glyphs. The images are all the same size, 128 × 128 = 16384 pixels, and greyscale (single-channel color). Thus an obvious choice for the representation is a vector \\(\\mathbf{x}\\) of length 16384, where each element corresponds to the color of one pixel: \\(\\mathbf{x} = (x_{1}, x_{2}, ... , x_{16384})\\). We can call the domain of all possible images for our dataset “pixel space”.\nA few samples from the “glyffuser” training set.\nDataset visualization We make the assumption that our individual data samples, \\(x\\), are actually sampled from an underlying probability distribution, \\(q(x)\\), in pixel space, much as the samples from our first example were sampled from an underlying normal distribution in 1-dimensional space. Note: the notation \\(x \\sim q(x)\\) is commonly used to mean: “the random variable \\(x\\) sampled from the probability distribution \\(q(x)\\).”\nThis distribution is clearly much more complex than a Gaussian and cannot be easily parameterized — we need to learn it with a ML model, which we’ll discuss later. First, let’s try to visualize the distribution to gain a better intution.\nAs humans find it difficult to see in more than 3 dimensions, we need to reduce the dimensionality of our data. A small digression on why this works: the manifold hypothesis posits that natural datasets lie on lower dimensional manifolds embedded in a higher dimensional space—think of a line embedded in a 2-D plane, or a plane embedded in 3-D space. We can use a dimensionality reduction technique such as UMAP to project our dataset from 16384 to 2 dimensions. The 2-D projection retains a lot of structure, consistent with the idea that our data lie on a lower dimensional manifold embedded in pixel space. In our UMAP, we see two large clusters corresponding to characters in which the components are arranged either horizontally or vertically—you can confirm this on the interactive plot below!\nLet’s now use this low-dimensional UMAP dataset as a visual shorthand for our high-dimensional dataset. Remember, we assume that these individual points have been sampled from the continuous underlying probability distribution \\(q(x)\\). To get a sense of what this distribution might look like, we can apply a KDE (kernel density estimation) over the UMAP dataset. (Note: this is just an approximation for visualization purposes)\nThis gives a sense of what \\(q(x)\\) should look like: clusters of glyphs correspond to high-probability regions of the distribution. The true \\(q(x)\\) lies in 16384 dimensions—this is the distribution we want to learn with our diffusion model.\nWe showed that for a simple distribution such as the 1-D Gaussian, we could calculate the parameters (mean and variance) from our data. However, for complex distributions such as images, we need to call on ML methods. Moreover, what we will find is that for diffusion models in practice, rather than parameterizing the distribution directly, they learn it implicitly through the process of learning how to transform noise into data over many steps.\nTakeaway The aim of generative AI such as diffusion models is to learn the complex probability distributions underlying their training data.\nHow and why do diffusion models work? Diffusion models have recently come into the spotlight as a particularly effective method for learning these probability distributions. They generate convincing images by starting from pure noise and gradually refining it. To whet your interest, have a look at the animation below that shows the denoising process for 16 samples. For readers who are not familiar with Chinese characters: the generated samples do look fairly similar to real characters!\nYour browser does not support the video tag.\rIn this section we’ll only talk about the mechanics of how these models work but if you’re interested in the broader context, I recommend the articles linked in the intro, particularly this one.\nWhat is “noise”? Let’s first precisely define noise, since the term is thrown around a lot in the context of diffusion. In particular, we are talking about Gaussian noise: consider the samples we talked about in the section about probability distributions. You could think of each sample as an image of a single pixel of noise. An image that is “pure Gaussian noise”, then, is one in which each pixel value is sampled from an independent standard Gaussian distribution, \\(\\mathcal{N}(0,1)\\). For a pure noise image in the domain of our glyph dataset, this would be noise drawn from 16384 separate Gaussian distributions.\nFor convenience, you will find the noise distributions for image datasets written as a single multivariate distribution \\(\\mathcal{N}(0,I)\\) where \\(I\\) is the identity matrix, a covariance matrix with all diagonal entries equal to 1 and zeroes elsewhere. This is simply a compact notation for a set of multiple independent Gaussians - i.e. there are no correlations between the noise on different pixels. In the basic implementations of diffusion models, only uncorrelated (a.k.a. “isotropic”) noise is used. This article contains an excellent interactive introduction on multivariate Gaussians.\nDiffusion process overview Below is an adaptation of the now-famous diagram from Ho et al.’s seminal paper “Denoising Diffusion Probabilistic Models”:\nDiagram of the diffusion process adapted from Ho et al. 2020. The glyph 锂, meaning “lithium”, is used as a representative sample from the dataset\nI found that there was a lot to unpack in this diagram and simply understanding what each component meant was very helpful, so let’s go through it and define everything step by step.\nWe previously used \\(x \\sim q(x)\\) to refer to our data. Here, we’ve added a subscript, \\(x_t\\), to denote timestep \\(t\\) indicating how many steps of “noising” have taken place. We refer to the samples noised a given timestep as \\(x_{t} \\sim q(x_{t})\\). \\(x_0\\) is clean data and \\(x_{T} \\sim \\mathcal{N}(0,I)\\) is pure noise.\nA forward diffusion process whereby we corrupt samples with noise comes from the distribution \\(q(x_{t}|x_{t-1})\\). If we could access the hypothetical reverse process \\(q(x_{t-1}|x_{t})\\), we could generate samples from noise. As we cannot access it directly, we use ML to learn the parameters, \\(\\theta\\), of a model of this process, \\(p_{\\theta}(x_{t-1}|x_{t})\\).\nIn the following sections we go into detail on how the forward and reverse diffusion processes work.\nForward diffusion, or “noising” Used as a verb, “noising” an image refers to applying a transformation that moves it towards pure noise by scaling down its pixel values toward 0 while adding proportional Gaussian noise. To apply the transformation to an image, we define a multivariate Gaussian distribution where the mean values of each dimension are equal to the pixel values of that image, then sample from it.\nIn the forward diffusion process, this noising distribution is written as \\(q(x_{t}|x_{t-1})\\) where the vertical bar symbol “|” is read as “given” or “conditional on, indicating the pixel means are passed forward from \\(q(x_{t-1})\\). At \\(t = T\\) where \\(T\\) is a large number (commonly 1000) we aim to end up with images of pure noise. I give two intutions for conditioning below and later in the article. The marginal distributions \\(q(x_{t})\\) represent the distributions that have accumulated the effects of all the previous noising steps (marginalization refers to integration over all possible conditions, which recovers an unconditioned distribution).\nSince the conditional distributions are Gaussian, what about their variance? They are determined by a variance schedule that maps timesteps to variance values. Initially, an empirically determined schedule of linearly increasing values from 0.0001 to 0.02 over 1000 steps was presented in Ho et al. Later research by Nichol \u0026 Dhariwal suggested an improved cosine schedule. They state that schedule is most effective when the rate of information destruction through noising is relatively even per step throughout the whole noising process.\nForward diffusion intuition Below I try to give a visual intution of a single noising step, \\(q(x_{1}|x_{0})\\), for some arbitrary, structured 2-dimensional data (you could consider the x and y directions in these plots as corresponding to the pixel values of a two-pixel image, for example):\nEach noising step \\(q(x_{t}|x_{t-1})\\) is a Gaussian distribution conditioned on the previous step.\nThe right panel of figure the above shows the shape of the overall noised distribution \\(q(x_{1}|x_{0})\\) (light gray) and the distribution \\(q(x_{1}|x_{0} = x_0^{(i)})\\) (dark grey) for several individual example points \\(x_0^{(i)}\\) (orange) as clouds of points sampled from their respective distributions. Any subsequent timestep can be accessed by repeated applications of noising steps.\nNote: the chain of Gaussian distributions is itself a Gaussian distribution. This is important for computational efficiency, as rather than performing a sequence of noising steps we can actually access the distribution for any given timestep, \\(q(x_{t}|x_{0})\\), in a single calculation by calculating the appropriate scaling factor and variance from the variance schedule directly.\nForward diffusion visualization Let’s now return to our glyph dataset (once again using the UMAP visualization as a visual shorthand). The top row of the figure below shows our dataset noised to various timesteps: \\(x_{t} \\sim q(x_t)\\). As we increase the number of noising steps, you can see that the dataset begins to resemble pure Gaussian noise. The bottom row visualizes the underlying probability distribution \\(q(x_{t})\\).\nAt different noising timesteps: (top) the dataset \\(x_t\\), (middle) probability distribution of dataset \\(q(x_{t})\\), (bottom) score function \\(\\nabla_{x}\\log q(x_{t})\\).\nLearning the reverse diffusion process It follows that if we knew the reverse distributions \\(q(x_{t-1}|x_{t})\\), we could repeatedly subtract noise from pure noise \\(x_{T}\\) to arrive at a data sample \\(x_{0} \\sim q(x_{0})\\). In practice, however, we cannot access these distributions without knowing \\(x_{0}\\) beforehand. Intuitively, it’s easy make a known image much noisier but given a very noisy image, it’s much harder to guess what the original image was.\nSo what are we to do? Essentially, by leveraging the large amount of data we have, we can train a ML model to accurately guess the original image that any given noisy image came from. Specifically, we learn the parameters \\(\\theta\\) of a ML model that approximates the reverse noising distributions, \\(p_{\\theta}(x_{t-1}|x_{t})\\) for \\(t = 0, ..., T\\).\nA ML model that can predict added noise at any given timestep \\(t\\) allows us to sample from the underlying distribution via sequential denoising.\nTo make it concrete, this is how the model is implemented (see also the figure below): for each training instance, we take a random image from our dataset and noise it to a random timestep \\(t\\). We then train a ML model to predict the (known) noise in the image, conditioned on the timestep \\(t\\) (see here for a discussion of how timestep conditioning is implemented). This is mathematically equivalent to predicting the noise-free data, \\(x_0\\), (shown as the dotted arrow in the figure) but easier computationally. Our training loss is some measure of the difference between the predicted and actual noise, such as the mean square error. In practice, any ML model that inputs and outputs data of the correct size can be used; the U-net, an architecture developed for biomedical imaging that takes account of different length scales, is frequently chosen in practice.\nNote: generally, ML models are trained by iteratively updating their parameters to minimize a given loss function over many training data examples. This is an excellent introduction.\nIn our implementation we use the U-net architecture (Ronneberger et al. 2015) for our ML noise prediction model. We train the model by minimizing the difference between predicted and actual noise.\nA model trained in this way eventually sees many different combinations of timesteps and data examples. The glyffuser, for example, was trained over 100 epochs (runs through the whole data set), so it saw around 2 million data samples. Through this process, the model implicity learns the reverse diffusion distributions over the entire dataset at all different timesteps. This allows the model to sample the underlying distribution \\(q(x_0)\\) by stepwise denoising starting from pure noise. Put another way, given an image noised to any given level, the model can predict how to reduce the noise based on its guess of what the original image. By doing this repeatedly, updating its guess of the original image each time, the model can transform any noise to a sample that lies in a high-probability region of the underlying data distribution.\nReverse diffusion in practice Your browser does not support the video tag.\rWe can now revisit this video of the glyffuser denoising process. Recall a large number of steps from sample to noise e.g. \\(T=1000\\) is used during training to make the noise-to-sample trajectory very easy for the model to learn, as changes between steps will be small. During sampling, however, we can effectively approximate this trajectory with fewer steps. The video above uses 120 steps, for instance (most implementations will allow the user to set the number of sampling steps). Too few steps, however, and the results become worse as the steps become too large for the model to effectively approximate the denoising trajectory. If we only use 5 sampling steps, for example, the sampled characters don’t look very good at all:\nYour browser does not support the video tag.\rThere is then a whole literature on more advanced sampling methods beyond what we’ve discussed so far, allowing effective sampling with much fewer steps. In production-level models, these are always preferred over the simple method discussed here, but the basic principle of deducing the noise-to-sample trajectory is the same. A full discussion is beyond the scope of this article but see e.g. this paper and its corresponding implementation in the Hugging Face diffusers library for more information.\nAlternative intuition from score function To me, it was still not 100% clear why training the model on noise prediction generalises so well. I found that an alternative interpretation of diffusion models known as “score-based modeling” filled some of the gaps in intuition (for more information, refer to Yang Song’s definitive article on the topic.)\nAt different noising timesteps: (top) the dataset \\(x_t\\), (middle) probability distribution of dataset \\(q(x_{t})\\), (bottom) score function \\(\\nabla_{x}\\log q(x_{t})\\).\nI try to give a visual intuition in the bottom row of the figure above: essentially, learning the noise in our diffusion model is equivalent (to a constant factor) to learning the score function, which is the gradient of the log of the probability distribution: \\(\\nabla_{x} \\log q(x)\\). As a gradient, the score function can be represented as a vector field with vectors pointing towards the regions of highest probability density. Subtracting the noise at each step is then equivalent to moving following the directions in this vector field towards regions of high probability density.\nAs long as there is some signal, the score function effectively guides sampling, but in regions of low probability it tends towards zero as there is little to no gradient to follow. Using many steps to cover different noise levels allows us to avoid this, as we smear out the gradient field at high noise levels, allowing sampling to converge even if we start from low probability density regions of the distribution. The figure shows that as the noise level is increased, more of the domain is covered by the score function vector field.\nSummary The aim of our generative process is to start at a random point in our pixel space and transform it into a realistic data point step-by-step by guiding it toward high-probability regions in our the data distribution (moving it onto the data manifold). The forward noising process takes samples from our dataset and gradually adds Gaussian noise (pushes them off the data manifold). This forward process is computationally efficient because noise can be added analytically in a single step. The reverse noising process is challenging because we need to predict how to remove the noise at each step without knowing the original data point in advance. To address this, we train a ML model to predict the noise added at each step by giving it many examples of noised data at different timesteps. Using very small steps in the forward noising process makes it easier for the model to learn to reverse these steps, as the changes are small. By applying the reverse noising process iteratively, the model refines the noisy sample step by step, eventually producing a realistic data point (one that lies on the data manifold). Takeaway Diffusion models are a powerful framework for learning complex data distributions. The distributions are learnt implicitly by modelling a sequential denoising process. This process can then be used to generate samples similar to those in the training distribution.\nOnce you’ve trained a model, how do you get useful stuff out of it? Earlier uses of generative AI such as “This Person Does Not Exist” (ca. 2019) made waves simply because it was the first time most people had seen AI-generated photorealistic human faces. A generative adversarial network or “GAN” was used in that case, but the principle remains the same: the model implicitly learnt a underlying data distribution—in that case, human faces—then sampled from it. So far, our glyffuser model does a similar thing: it samples randomly from the distribution of Chinese glyphs.\nThe question then arises: can we do more than just sample randomly? You’ve likely already encountered and used text-to-image models such as Dall-E. They are able to incorporate extra meaning from text prompts into the diffusion process - this in known as conditioning. Likewise, diffusion models for scientific scientific applications like protein (e.g. Chroma, RFdiffusion, AlphaFold3) or inorganic crystal structure generation (e.g. MatterGen) become much more useful if can be conditioned to generate samples with desirable properties such as a specific symmetry, bulk modulus, or band gap.\nConditional distributions We can consider conditioning as a way to guide the diffusion sampling process towards particular regions of our probability distribution. We gave one visual intution of conditional distributions earlier in the article; the figure below shows an alternative one.\nA simple example of a joint probability distribution \\(p(x, y)\\) shown as a contour map and its two marginal 1-D probability distributions, \\(p(x)\\) and \\(p(y)\\). The highest points of \\(p(x, y)\\) are at \\((x1, y1)\\) and \\((x2, y2)\\). The conditional distributions \\(p(x|y=y_1)\\) and \\(p(x|y=y_2)\\) are shown overlaid on the main plot.\nConsider the figure above. Think of \\(p(x)\\) as being a simplified 1-D version of the underlying distribution of a glyph dataset, and \\(p(y)\\) as being the corresponding distribution of a text dataset. These are the marginal distributions of the joint distribution, obtained by integrating the joint over all possible values of conditioning variable as mentioned above. We can obtain a conditioned distribution \\(p(x|y=y_1)\\) by taking a slice through the joint distribution \\(p(x,y)\\) at a given value of \\(y\\).\nLet’s give an example. The Chinese character “木” means “wood”, while “火” means “fire”. Assume that we’ve converted these characters and words to 1-D representations. “木” lies at \\(x = x_1\\) while “火” lies at \\(x = x_2\\). “Wood” lies at \\(y = y_1\\) while “fire” lies at \\(y = y_2\\). In \\(p(x)\\), “木” and “火” are equally probable. However, if we condition \\(p(x)\\) on \\(p(y)\\), the conditional distributions \\(p(x|y)\\) clearly distinguish the values of “木” and “火” based on the conditioning values of “wood” or “fire”. This is the core idea behind how conditioning guides text-to-image diffusion models: text conditioning adjusts the underlying distribution of image dataset to favour regions associated with the text.\nIn practice, we can convert our text conditioning information (the character definitions) into a numerical form using large language model (LLM) embeddings that can be injected into the noise prediction model during training.\nEmbedding text with an LLM Let’s take the example of the glyffuser. Our conditioning information is in the form of English text definitions. We have two requirements: 1. As previously touched upon, ML models prefer fixed-length vectors as input, so we’d like a way to convert our text into this format. 2. This numerical representation of our text must understand the context - if we have the words “lithium” and “element” nearby, the meaning of “element” should be understood as “chemical element” rather than “heating element”. Both of these requirements can be met by using a pre-trained LLM.\nThe diagram below shows how a LLM converts text into fixed-length vectors. The text is first tokenized (LLMs break text into tokens, small chunks of characters, as their basic unit of interaction). Each token is converted into a base embedding, which is a fixed-length vector of the size of the LLM input. These vectors are then passed through the pre-trained LLM (here we use the encoder portion of Google’s T5 model), where they are imbued with additional contextual meaning. We end up with a array of n vectors of the same length d, i.e. a (n, d) sized tensor.\nWe can convert text to a numerical embedding imbued with contextual meaning using a pre-trained LLM.\nTraining the diffusion model with text conditioning The exact method that this embedding vector is injected into the model can vary. In Google’s Imagen model, for example, the embedding tensor is pooled (combined into a single vector in the embedding dimension) and added into the data as it passes through the noise prediction model; it is also included using in a different way using cross-attention (a method of learning contextual information between sequences of tokens, most famously used in the transformer models that form the basis of LLMs like ChatGPT).\nConditioning information can be added via multiple different methods but the training loss remains the same.\nIn the glyffuser, we only use cross-attention to introduce this conditioning information. While a significant architectural change is required to introduce this additional information into the model, the loss function for our noise prediction model remains exactly the same.\nTesting the conditioned diffusion model Let’s do a simple test of the fully trained conditioned diffusion model. In the figure below, we try to denoise in a single step with the text prompt “Gold”. As touched upon in our interactive UMAP, Chinese characters often contain components known as radicals which can convey sound (phonetic radicals) or meaning (semantic radicals). A common semantic radical is derived from the character meaning “gold”, “金”, and is used in characters that are in some broad sense associated with gold or metals.\nEven with a single sampling step, conditioning guides denoising towards the relevant regions of the probability distribution.\nThe figure shows that even though a single step is insufficient to approximate the denoising trajectory very well, we have activated the “金” radical. This indicates that the text prompt is very effectively guiding our sampling towards a region of the glyph probability distribution related to the meaning of the prompt. The animation below shows a 120 step denoising sequence for the same prompt.\nYour browser does not support the video tag.\rTakeaway Conditioning enables us to sample meaningful outputs from diffusion models.\nFurther remarks I found that with the help of tutorials and existing libraries, it was possible to implement a working diffusion model despite not having a full understanding of what was going on under the hood. I think this is a good way to start learning and highly recommend Hugging Face’s tutorial on training a simple diffusion model using their diffusers Python library (which now includes my small bugfix!).\nFor further reading, I direct you to the various articles I linked in the introduction and throughout this post.\n","wordCount":"4561","inLanguage":"en","datePublished":"2024-12-18T00:00:00Z","dateModified":"2024-12-18T00:00:00Z","author":{"@type":"Person","name":"Yue Wu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yue-here.com/posts/genai_intuitions/"},"publisher":{"@type":"Organization","name":"Yue Wu","logo":{"@type":"ImageObject","url":"https://yue-here.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yue-here.com/ accesskey=h title="Yue Wu (Alt + H)">Yue Wu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yue-here.com/index.html title=Home><span>Home</span></a></li><li><a href=https://yue-here.com/bio/ title=Bio><span>Bio</span></a></li><li><a href=https://yue-here.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://yue-here.com/research/ title=Research><span>Research</span></a></li><li><a href=https://yue-here.com/personal/ title=Personal><span>Personal</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">A visual guide to how diffusion models work
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2024-12-18 00:00:00 +0000 UTC'>December 18, 2024</span>&nbsp;·&nbsp;22 min&nbsp;·&nbsp;4561 words&nbsp;·&nbsp;Yue Wu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#what-exactly-is-it-that-diffusion-models-learn>What exactly is it that diffusion models learn?</a><ul><li><a href=#probability-distributions>Probability distributions</a></li><li><a href=#data-representations>Data representations</a></li><li><a href=#dataset-visualization>Dataset visualization</a></li><li><a href=#takeaway>Takeaway</a></li></ul></li><li><a href=#how-and-why-do-diffusion-models-work>How and why do diffusion models work?</a><ul><li><a href=#what-is-noise>What is &ldquo;noise&rdquo;?</a></li><li><a href=#diffusion-process-overview>Diffusion process overview</a></li><li><a href=#forward-diffusion-or-noising>Forward diffusion, or &ldquo;noising&rdquo;</a></li><li><a href=#forward-diffusion-intuition>Forward diffusion intuition</a></li><li><a href=#forward-diffusion-visualization>Forward diffusion visualization</a></li><li><a href=#learning-the-reverse-diffusion-process>Learning the reverse diffusion process</a></li><li><a href=#reverse-diffusion-in-practice>Reverse diffusion in practice</a></li><li><a href=#alternative-intuition-from-score-function>Alternative intuition from score function</a></li><li><a href=#summary>Summary</a></li><li><a href=#takeaway-1>Takeaway</a></li></ul></li><li><a href=#once-youve-trained-a-model-how-do-you-get-useful-stuff-out-of-it>Once you&rsquo;ve trained a model, how do you get useful stuff out of it?</a><ul><li><a href=#conditional-distributions>Conditional distributions</a></li><li><a href=#embedding-text-with-an-llm>Embedding text with an LLM</a></li><li><a href=#training-the-diffusion-model-with-text-conditioning>Training the diffusion model with text conditioning</a></li><li><a href=#testing-the-conditioned-diffusion-model>Testing the conditioned diffusion model</a></li><li><a href=#takeaway-2>Takeaway</a></li></ul></li><li><a href=#further-remarks>Further remarks</a></li></ul></nav></div></details></div><div class=post-content><p>This is an article for those who want to understand exactly what is going on in diffusion models, with no prior knowledge expected. Illustrations are used to provide visual intuitions on how each component of these models work. Any notation and equations are defined and explained clearly.</p><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><p>Diffusion models are one of the generative AI models <em>du jour</em>, being the core technology behind almost all popular text-to-image applications used today (see e.g. Dall-E, Stable Diffusion, Midjourney, Imagen). They are also seeing increasing usage in scientific fields such as my own area of materials science.</p><p>I recently had to give a talk on diffusion models, which led me to examine my own understanding. It turns out that they have a <a href=http://johnsalvatier.org/blog/2017/reality-has-a-surprising-amount-of-detail>surprising amount of detail</a> under the hood.
There are <a href=https://lilianweng.github.io/posts/2021-07-11-diffusion-models/>many</a> <a href=https://yang-song.net/blog/2021/score/>excellent</a> <a href=https://calvinyluo.com/2022/08/26/diffusion-tutorial.html>explainer</a> <a href=https://www.assemblyai.com/blog/minimagen-build-your-own-imagen-text-to-image-model/>articles</a> <a href=https://towardsdatascience.com/diffusion-models-91b75430ec2>on</a> <a href=https://sander.ai/2023/07/20/perspectives.html>the</a> subject, but I found it took me a while to understand them at a deep level due to the large amount of assumed knowledge required.</p><p>I&rsquo;ve tried to write the article I wish I had when I started trying to understand how diffusion works. This may be the article for you if you have a similar background to me - a STEM background and some coding experience, a bit rusty on the maths and stats. I aim to explain the intuitions behind how diffusion models work in a concrete way without sacrificing technical detail, but using minimal jargon and equations. When technical terms are necessary, I&rsquo;ve tried to clearly define them and bootstrap any mathematical notation within the article.</p><p>I&rsquo;ve framed this article around three main questions:</p><ul><li>What exactly is it that diffusion models learn?</li><li>How and why do diffusion models work?</li><li>Once you&rsquo;ve trained a model, how do you get useful stuff out of it?</li></ul><p>The examples will be based on the <a href=/posts/glyffuser/>glyffuser</a>, a minimal text-to-image diffusion model that I previously <a href=/posts/glyffuser/>implemented and wrote about</a>. The basic architecture of this model is a standard text-to-image denoising diffusion model, which is trained specifically to generate pictures of new &ldquo;Chinese&rdquo; glyphs from English definitions. This is a small but complete example of a diffusion model is useful for building intuition.</p><h2 id=what-exactly-is-it-that-diffusion-models-learn>What exactly is it that diffusion models learn?<a hidden class=anchor aria-hidden=true href=#what-exactly-is-it-that-diffusion-models-learn>#</a></h2><p>Generative AI models are often said to take a big pile of data and &ldquo;learn&rdquo; it. For text-to-image diffusion models the data takes the form of pairs of images and descriptive text. But what exactly is it that the model learns? First, let&rsquo;s forget about the text component for a moment and concentrate on the images.</p><h3 id=probability-distributions>Probability distributions<a hidden class=anchor aria-hidden=true href=#probability-distributions>#</a></h3><p>Generally, the purpose of any generative AI model is to learn the <em>underlying probability distribution</em> of the data. What does this mean? Consider the one-dimensional normal (Gaussian) distribution below, commonly written \(\mathcal{N}(\mu,\sigma^{2})\) with mean \(\mu = 0\) and variance \(\sigma^{2}=1\). The curve shows the probability density function. This distribution is parameterized by the mean and the variance, and we can easily sample from it computationally, e.g. with <code>x = random.gauss(0, 1)</code> in Python (although the computational sampling process itself is non-trivial).</p><figure class=align-center><img loading=lazy src=/Gaussian.png#center alt="Values sampled from an underlying distribution (here, the standard normal \(\mathcal{N}(0,1)\)) can then be used to estimate the parameters of that distribution."><figcaption><p>Values sampled from an underlying distribution (here, the standard normal \(\mathcal{N}(0,1)\)) can then be used to estimate the parameters of that distribution.</p></figcaption></figure><p>We could think of a set of numbers sampled from this normal distribution as a simple dataset, like that shown as the orange histogram above. In this particular case, we can calculate the parameters of the underlying distribution using <em>maximum likelihood estimation</em>, i.e. by working out the mean and variance. The normal distribution estimated from the dataset of 1000 samples is shown by the dotted line above. To take some liberties with terminology, you might consider this as a simple example of &ldquo;learning&rdquo; an underlying probability distribution. We can also say it <em>explicitly</em> learnt the distribution, in contrast with the <em>implicit</em> methods that diffusion models use.</p><h3 id=data-representations>Data representations<a hidden class=anchor aria-hidden=true href=#data-representations>#</a></h3><p>What, then, does the underlying probability distribution of a more complex dataset look like, such as image dataset we want to use to train our diffusion model?</p><p>First, we need to know what the <em>representation</em> of the data is. Generally, a machine learning (ML) model requires data inputs with a consistent representation, i.e. format. For the example above, it was simply numbers (scalars). For images, this representation is commonly a fixed-length vector.</p><p>The image dataset used for the glyffuser model is ~21,000 pictures of Chinese glyphs. The images are all the same size, 128 × 128 = 16384 pixels, and greyscale (single-channel color). Thus an obvious choice for the representation is a vector \(\mathbf{x}\) of length 16384, where each element corresponds to the color of one pixel: \(\mathbf{x} = (x_{1}, x_{2}, ... , x_{16384})\). We can call the domain of all possible images for our dataset &ldquo;pixel space&rdquo;.</p><figure class=align-center><img loading=lazy src=/glyph_dataset.png#center alt="A few samples from the &ldquo;glyffuser&rdquo; training set."><figcaption><p>A few samples from the &ldquo;glyffuser&rdquo; training set.</p></figcaption></figure><h3 id=dataset-visualization>Dataset visualization<a hidden class=anchor aria-hidden=true href=#dataset-visualization>#</a></h3><p>We make the assumption that our individual data samples, \(x\), are actually sampled from an underlying probability distribution, \(q(x)\), in pixel space, much as the samples from our first example were sampled from an underlying normal distribution in 1-dimensional space. Note: the notation \(x \sim q(x)\) is commonly used to mean: &ldquo;the random variable \(x\) sampled from the probability distribution \(q(x)\).&rdquo;</p><p>This distribution is clearly much more complex than a Gaussian and cannot be easily parameterized — we need to learn it with a ML model, which we&rsquo;ll discuss later. First, let&rsquo;s try to visualize the distribution to gain a better intution.</p><p>As humans find it difficult to see in more than 3 dimensions, we need to reduce the dimensionality of our data. A small digression on why this works: the <a href=https://en.wikipedia.org/wiki/Manifold_hypothesis>manifold hypothesis</a> posits that natural datasets lie on lower dimensional manifolds embedded in a higher dimensional space—think of a line embedded in a 2-D plane, or a plane embedded in 3-D space. We can use a dimensionality reduction technique such as <a href=https://umap-learn.readthedocs.io/en/latest/>UMAP</a> to project our dataset from 16384 to 2 dimensions. The 2-D projection retains a lot of structure, consistent with the idea that our data lie on a lower dimensional manifold embedded in pixel space. In our UMAP, we see two large clusters corresponding to characters in which the components are arranged either horizontally or vertically—you can confirm this on the <strong>interactive plot</strong> below!</p><p><script src=https://cdn.plot.ly/plotly-latest.min.js></script><div id=/umap.json class=plotly style=width:100%></div><script>Plotly.d3.json("/umap.json",function(e,t){Plotly.plot("/umap.json",t.data,t.layout,{responsive:!0})})</script></p><p>Let&rsquo;s now use this low-dimensional UMAP dataset as a visual shorthand for our high-dimensional dataset. Remember, we assume that these individual points have been sampled from the continuous underlying probability distribution \(q(x)\). To get a sense of what this distribution might look like, we can apply a KDE (kernel density estimation) over the UMAP dataset. (Note: this is just an approximation for visualization purposes)</p><figure class=align-center><img loading=lazy src=/manifold2PD.png#center></figure><p>This gives a sense of what \(q(x)\) should look like: clusters of glyphs correspond to high-probability regions of the distribution. The true \(q(x)\) lies in 16384 dimensions—this is the distribution we want to learn with our diffusion model.</p><p>We showed that for a simple distribution such as the 1-D Gaussian, we could calculate the parameters (mean and variance) from our data. However, for complex distributions such as images, we need to call on ML methods. Moreover, what we will find is that for diffusion models in practice, rather than parameterizing the distribution directly, they learn it <em>implicitly</em> through the process of learning how to transform noise into data over many steps.</p><h3 id=takeaway>Takeaway<a hidden class=anchor aria-hidden=true href=#takeaway>#</a></h3><p>The aim of generative AI such as diffusion models is to learn the complex probability distributions underlying their training data.</p><h2 id=how-and-why-do-diffusion-models-work>How and why do diffusion models work?<a hidden class=anchor aria-hidden=true href=#how-and-why-do-diffusion-models-work>#</a></h2><p>Diffusion models have recently come into the spotlight as a particularly effective method for learning these probability distributions. They generate convincing images by starting from pure noise and gradually refining it. To whet your interest, have a look at the animation below that shows the denoising process for 16 samples. For readers who are not familiar with Chinese characters: the generated samples do look fairly similar to real characters!</p><center><video width=80% autoplay loop muted playsinline>
<source src=/unconditional_glyffuser_denoising.mp4 type=video/mp4>Your browser does not support the video tag.</video></center><p>In this section we&rsquo;ll only talk about the mechanics of how these models work but if you&rsquo;re interested in the broader context, I recommend the articles linked in the <a href=#intro>intro</a>, particularly <a href=https://towardsdatascience.com/diffusion-models-91b75430ec2>this one</a>.</p><h3 id=what-is-noise>What is &ldquo;noise&rdquo;?<a hidden class=anchor aria-hidden=true href=#what-is-noise>#</a></h3><p>Let&rsquo;s first precisely define noise, since the term is thrown around a lot in the context of diffusion. In particular, we are talking about Gaussian noise: consider the samples we talked about in the section about <a href=#probability-distributions>probability distributions</a>. You could think of each sample as an image of a single pixel of noise. An image that is &ldquo;pure Gaussian noise&rdquo;, then, is one in which each pixel value is sampled from an independent standard Gaussian distribution, \(\mathcal{N}(0,1)\). For a pure noise image in the domain of our glyph dataset, this would be noise drawn from 16384 separate Gaussian distributions.</p><p>For convenience, you will find the noise distributions for image datasets written as a single multivariate distribution \(\mathcal{N}(0,I)\) where \(I\) is the identity matrix, a covariance matrix with all diagonal entries equal to 1 and zeroes elsewhere. This is simply a compact notation for a set of multiple independent Gaussians - i.e. there are no correlations between the noise on different pixels. In the basic implementations of diffusion models, only uncorrelated (a.k.a. &ldquo;isotropic&rdquo;) noise is used. <a href=https://distill.pub/2019/visual-exploration-gaussian-processes/>This article</a> contains an excellent interactive introduction on multivariate Gaussians.</p><h3 id=diffusion-process-overview>Diffusion process overview<a hidden class=anchor aria-hidden=true href=#diffusion-process-overview>#</a></h3><p>Below is an adaptation of the now-famous diagram from <a href=https://arxiv.org/abs/2006.11239>Ho <em>et al</em>.</a>&rsquo;s seminal paper &ldquo;<em>Denoising Diffusion Probabilistic Models</em>&rdquo;:</p><figure class=align-center><img loading=lazy src=/diffusion_schematic.png#center alt="Diagram of the diffusion process adapted from Ho et al. 2020. The glyph 锂, meaning &ldquo;lithium&rdquo;, is used as a representative sample from the dataset"><figcaption><p>Diagram of the diffusion process adapted from <a href=https://arxiv.org/abs/2006.11239>Ho <em>et al</em>. 2020</a>. The glyph 锂, meaning &ldquo;lithium&rdquo;, is used as a representative sample from the dataset</p></figcaption></figure><p>I found that there was a lot to unpack in this diagram and simply understanding what each component meant was very helpful, so let&rsquo;s go through it and define everything step by step.</p><p>We previously used \(x \sim q(x)\) to refer to our data. Here, we&rsquo;ve added a subscript, \(x_t\), to denote timestep \(t\) indicating how many steps of &ldquo;noising&rdquo; have taken place. We refer to the samples noised a given timestep as \(x_{t} \sim q(x_{t})\). \(x_0\) is clean data and \(x_{T} \sim \mathcal{N}(0,I)\) is pure noise.</p><p>A forward diffusion process whereby we corrupt samples with noise comes from the distribution \(q(x_{t}|x_{t-1})\). If we could access the hypothetical reverse process \(q(x_{t-1}|x_{t})\), we could generate samples from noise. As we cannot access it directly, we use ML to learn the parameters, \(\theta\), of a model of this process, \(p_{\theta}(x_{t-1}|x_{t})\).</p><p>In the following sections we go into detail on how the forward and reverse diffusion processes work.</p><h3 id=forward-diffusion-or-noising>Forward diffusion, or &ldquo;noising&rdquo;<a hidden class=anchor aria-hidden=true href=#forward-diffusion-or-noising>#</a></h3><p>Used as a verb, &ldquo;noising&rdquo; an image refers to applying a transformation that moves it towards pure noise by scaling down its pixel values toward 0 while adding proportional Gaussian noise. To apply the transformation to an image, we define a multivariate Gaussian distribution where the mean values of each dimension are equal to the pixel values of that image, then sample from it.</p><p>In the forward diffusion process, this noising distribution is written as \(q(x_{t}|x_{t-1})\) where the vertical bar symbol &ldquo;|&rdquo; is read as &ldquo;given&rdquo; or &ldquo;conditional on, indicating the pixel means are passed forward from \(q(x_{t-1})\). At \(t = T\) where \(T\) is a large number (commonly 1000) we aim to end up with images of pure noise. I give two intutions for conditioning <a href=#forward-diffusion-intuition>below</a> and <a href=#conditional-distributions>later in the article</a>.
The <em>marginal</em> distributions \(q(x_{t})\) represent the distributions that have accumulated the effects of all the previous noising steps (<em>marginalization</em> refers to integration over all possible conditions, which recovers an unconditioned distribution).</p><p>Since the conditional distributions are Gaussian, what about their variance? They are determined by a <em>variance schedule</em> that maps timesteps to variance values. Initially, an empirically determined schedule of linearly increasing values from 0.0001 to 0.02 over 1000 steps was presented in <a href=https://arxiv.org/abs/2006.11239>Ho <em>et al</em>.</a> Later research by <a href=https://arxiv.org/pdf/2102.09672>Nichol & Dhariwal</a> suggested an improved cosine schedule. They state that schedule is most effective when the rate of information destruction through noising is relatively even per step throughout the whole noising process.</p><h3 id=forward-diffusion-intuition>Forward diffusion intuition<a hidden class=anchor aria-hidden=true href=#forward-diffusion-intuition>#</a></h3><p>Below I try to give a visual intution of a single noising step, \(q(x_{1}|x_{0})\), for some arbitrary, structured 2-dimensional data (you could consider the x and y directions in these plots as corresponding to the pixel values of a two-pixel image, for example):</p><figure class=align-center><img loading=lazy src=/noising_step.png#center alt="Each noising step \(q(x_{t}|x_{t-1})\) is a Gaussian distribution conditioned on the previous step."><figcaption><p>Each noising step \(q(x_{t}|x_{t-1})\) is a Gaussian distribution conditioned on the previous step.</p></figcaption></figure><p>The right panel of figure the above shows the shape of the overall noised distribution \(q(x_{1}|x_{0})\) (light gray) and the distribution \(q(x_{1}|x_{0} = x_0^{(i)})\) (dark grey) for several individual example points \(x_0^{(i)}\) (orange) as clouds of points sampled from their respective distributions. Any subsequent timestep can be accessed by repeated applications of noising steps.</p><p>Note: the chain of Gaussian distributions is itself a Gaussian distribution. This is important for computational efficiency, as rather than performing a sequence of noising steps we can actually access the distribution for any given timestep, \(q(x_{t}|x_{0})\), in a single calculation by calculating the appropriate scaling factor and variance from the variance schedule directly.</p><h3 id=forward-diffusion-visualization>Forward diffusion visualization<a hidden class=anchor aria-hidden=true href=#forward-diffusion-visualization>#</a></h3><p>Let&rsquo;s now return to our glyph dataset (once again using the <a href=#dataset-visualization>UMAP visualization</a> as a visual shorthand). The top row of the figure below shows our dataset noised to various timesteps: \(x_{t} \sim q(x_t)\). As we increase the number of noising steps, you can see that the dataset begins to resemble pure Gaussian noise. The bottom row visualizes the underlying probability distribution \(q(x_{t})\).</p><figure class=align-center><img loading=lazy src=/noised_PD_only.png#center alt="At different noising timesteps: (top) the dataset \(x_t\), (middle) probability distribution of dataset \(q(x_{t})\), (bottom) score function \(\nabla_{x}\log q(x_{t})\)."><figcaption><p>At different noising timesteps: (top) the dataset \(x_t\), (middle) probability distribution of dataset \(q(x_{t})\), (bottom) score function \(\nabla_{x}\log q(x_{t})\).</p></figcaption></figure><h3 id=learning-the-reverse-diffusion-process>Learning the reverse diffusion process<a hidden class=anchor aria-hidden=true href=#learning-the-reverse-diffusion-process>#</a></h3><p>It follows that if we knew the reverse distributions \(q(x_{t-1}|x_{t})\), we could repeatedly subtract noise from pure noise \(x_{T}\) to arrive at a data sample \(x_{0} \sim q(x_{0})\). In practice, however, we cannot access these distributions without knowing \(x_{0}\) beforehand. Intuitively, it&rsquo;s easy make a known image much noisier but given a very noisy image, it&rsquo;s much harder to guess what the original image was.</p><p>So what are we to do? Essentially, by leveraging the large amount of data we have, we can train a ML model to accurately guess the original image that any given noisy image came from. Specifically, we learn the parameters \(\theta\) of a ML model that approximates the reverse noising distributions, \(p_{\theta}(x_{t-1}|x_{t})\) for \(t = 0, ..., T\).</p><figure class=align-center><img loading=lazy src=/noise_prediction.png#center alt="A ML model that can predict added noise at any given timestep \(t\) allows us to sample from the underlying distribution via sequential denoising."><figcaption><p>A ML model that can predict added noise at any given timestep \(t\) allows us to sample from the underlying distribution <em>via</em> sequential denoising.</p></figcaption></figure><p>To make it concrete, this is how the model is implemented (see also the figure below): for each training instance, we take a random image from our dataset and noise it to a random timestep \(t\). We then train a ML model to predict the (known) noise in the image, conditioned on the timestep \(t\) (see <a href=https://www.assemblyai.com/blog/how-imagen-actually-works/>here</a> for a discussion of how timestep conditioning is implemented). This is mathematically equivalent to predicting the noise-free data, \(x_0\), (shown as the dotted arrow in the figure) but easier computationally. Our training loss is some measure of the difference between the predicted and actual noise, such as the mean square error. In practice, any ML model that inputs and outputs data of the correct size can be used; the <a href=https://arxiv.org/abs/1505.04597>U-net</a>, an architecture developed for biomedical imaging that takes account of different length scales, is frequently chosen in practice.</p><p>Note: generally, ML models are trained by iteratively updating their parameters to minimize a given loss function over many training data examples. <a href=https://www.3blue1brown.com/topics/neural-networks>This</a> is an excellent introduction.</p><figure class=align-center><img loading=lazy src=/unet_model.png#center alt="In our implementation we use the U-net architecture (Ronneberger et al. 2015) for our ML noise prediction model. We train the model by minimizing the difference between predicted and actual noise."><figcaption><p>In our implementation we use the U-net architecture (<a href=https://arxiv.org/abs/1505.04597>Ronneberger <em>et al</em>. 2015</a>) for our ML noise prediction model. We train the model by minimizing the difference between predicted and actual noise.</p></figcaption></figure><p>A model trained in this way eventually sees many different combinations of timesteps and data examples. The glyffuser, for example, was trained over 100 <em>epochs</em> (runs through the whole data set), so it saw around 2 million data samples. Through this process, the model implicity learns the reverse diffusion distributions over the entire dataset at all different timesteps. This allows the model to sample the underlying distribution \(q(x_0)\) by stepwise denoising starting from pure noise. Put another way, given an image noised to any given level, the model can predict how to reduce the noise based on its guess of what the original image. By doing this repeatedly, updating its guess of the original image each time, the model can transform any noise to a sample that lies in a high-probability region of the underlying data distribution.</p><h3 id=reverse-diffusion-in-practice>Reverse diffusion in practice<a hidden class=anchor aria-hidden=true href=#reverse-diffusion-in-practice>#</a></h3><center><video width=80% autoplay loop muted playsinline>
<source src=/unconditional_glyffuser_denoising.mp4 type=video/mp4>Your browser does not support the video tag.</video></center><p>We can now revisit this video of the glyffuser denoising process. Recall a large number of steps from sample to noise e.g. \(T=1000\) is used during training to make the noise-to-sample trajectory very easy for the model to learn, as changes between steps will be small. During sampling, however, we can effectively approximate this trajectory with fewer steps. The video above uses 120 steps, for instance (most implementations will allow the user to set the number of sampling steps). Too few steps, however, and the results become worse as the steps become too large for the model to effectively approximate the denoising trajectory. If we only use 5 sampling steps, for example, the sampled characters don&rsquo;t look very good at all:</p><center><video width=80% autoplay loop muted playsinline>
<source src=/uncon_denoising_5step.mp4 type=video/mp4>Your browser does not support the video tag.</video></center><p>There is then a whole literature on more advanced sampling methods beyond what we&rsquo;ve discussed so far, allowing effective sampling with much fewer steps. In production-level models, these are always preferred over the simple method discussed here, but the basic principle of deducing the noise-to-sample trajectory is the same. A full discussion is beyond the scope of this article but see e.g. <a href=https://arxiv.org/abs/2206.00364>this paper</a> and its corresponding <a href=https://huggingface.co/docs/diffusers/en/api/schedulers/overview>implementation</a> in the Hugging Face <code>diffusers</code> library for more information.</p><h3 id=alternative-intuition-from-score-function>Alternative intuition from score function<a hidden class=anchor aria-hidden=true href=#alternative-intuition-from-score-function>#</a></h3><p>To me, it was still not 100% clear why training the model on noise prediction generalises so well. I found that an alternative interpretation of diffusion models known as &ldquo;score-based modeling&rdquo; filled some of the gaps in intuition (for more information, refer to Yang Song&rsquo;s <a href=https://yang-song.net/blog/2021/score/>definitive article</a> on the topic.)</p><figure class=align-center><img loading=lazy src=/noised_PD_scorefunction.png#center alt="At different noising timesteps: (top) the dataset \(x_t\), (middle) probability distribution of dataset \(q(x_{t})\), (bottom) score function \(\nabla_{x}\log q(x_{t})\)."><figcaption><p>At different noising timesteps: (top) the dataset \(x_t\), (middle) probability distribution of dataset \(q(x_{t})\), (bottom) score function \(\nabla_{x}\log q(x_{t})\).</p></figcaption></figure><p>I try to give a visual intuition in the bottom row of the figure above: essentially, learning the noise in our diffusion model is <a href=https://calvinyluo.com/2022/08/26/diffusion-tutorial.html>equivalent</a> (to a constant factor) to learning the <em>score function</em>, which is the gradient of the log of the probability distribution: \(\nabla_{x} \log q(x)\). As a gradient, the score function can be represented as a vector field with vectors pointing towards the regions of highest probability density. Subtracting the noise at each step is then equivalent to moving following the directions in this vector field towards regions of high probability density.</p><p>As long as there is some signal, the score function effectively guides sampling, but in regions of low probability it tends towards zero as there is little to no gradient to follow. Using many steps to cover different noise levels allows us to avoid this, as we smear out the gradient field at high noise levels, allowing sampling to converge even if we start from low probability density regions of the distribution. The figure shows that as the noise level is increased, more of the domain is covered by the score function vector field.</p><h3 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h3><ul><li>The aim of our generative process is to start at a random point in our pixel space and transform it into a realistic data point step-by-step by guiding it toward high-probability regions in our the data distribution (moving it onto the data manifold).</li><li>The forward noising process takes samples from our dataset and gradually adds Gaussian noise (pushes them off the data manifold).</li><li>This forward process is computationally efficient because noise can be added analytically in a single step.</li><li>The reverse noising process is challenging because we need to predict how to remove the noise at each step without knowing the original data point in advance.</li><li>To address this, we train a ML model to predict the noise added at each step by giving it many examples of noised data at different timesteps.</li><li>Using very small steps in the forward noising process makes it easier for the model to learn to reverse these steps, as the changes are small.</li><li>By applying the reverse noising process iteratively, the model refines the noisy sample step by step, eventually producing a realistic data point (one that lies on the data manifold).</li></ul><h3 id=takeaway-1>Takeaway<a hidden class=anchor aria-hidden=true href=#takeaway-1>#</a></h3><p>Diffusion models are a powerful framework for learning complex data distributions. The distributions are learnt implicitly by modelling a sequential denoising process. This process can then be used to generate samples similar to those in the training distribution.</p><h2 id=once-youve-trained-a-model-how-do-you-get-useful-stuff-out-of-it>Once you&rsquo;ve trained a model, how do you get useful stuff out of it?<a hidden class=anchor aria-hidden=true href=#once-youve-trained-a-model-how-do-you-get-useful-stuff-out-of-it>#</a></h2><p>Earlier uses of generative AI such as &ldquo;<a href=https://thispersondoesnotexist.com/>This Person Does Not Exist</a>&rdquo; (<em>ca</em>. 2019) made waves simply because it was the first time most people had seen AI-generated photorealistic human faces. A generative adversarial network or &ldquo;GAN&rdquo; was used in that case, but the principle remains the same: the model implicitly learnt a underlying data distribution—in that case, human faces—then sampled from it. So far, our glyffuser model does a similar thing: it samples randomly from the distribution of Chinese glyphs.</p><p>The question then arises: can we do more than just sample randomly? You&rsquo;ve likely already encountered and used text-to-image models such as Dall-E. They are able to incorporate extra meaning from text prompts into the diffusion process - this in known as <em>conditioning</em>. Likewise, diffusion models for scientific scientific applications like protein (e.g. <a href=https://github.com/generatebio/chroma>Chroma</a>, <a href=https://github.com/RosettaCommons/RFdiffusion>RFdiffusion</a>, <a href=https://github.com/google-deepmind/alphafold3>AlphaFold3</a>) or inorganic crystal structure generation (e.g. <a href=https://arxiv.org/abs/2312.03687>MatterGen</a>) become much more useful if can be conditioned to generate samples with desirable properties such as a specific symmetry, bulk modulus, or band gap.</p><h3 id=conditional-distributions>Conditional distributions<a hidden class=anchor aria-hidden=true href=#conditional-distributions>#</a></h3><p>We can consider conditioning as a way to guide the diffusion sampling process towards particular regions of our probability distribution. We gave one visual intution of conditional distributions <a href=#forward-diffusion-intuition>earlier in the article</a>; the figure below shows an alternative one.</p><figure class=align-center><img loading=lazy src=/conditional_distributions.png#center alt="A simple example of a joint probability distribution \(p(x, y)\) shown as a contour map and its two marginal 1-D probability distributions, \(p(x)\) and \(p(y)\). The highest points of \(p(x, y)\) are at \((x1, y1)\) and \((x2, y2)\). The conditional distributions \(p(x|y=y_1)\) and \(p(x|y=y_2)\) are shown overlaid on the main plot."><figcaption><p>A simple example of a joint probability distribution \(p(x, y)\) shown as a contour map and its two marginal 1-D probability distributions, \(p(x)\) and \(p(y)\). The highest points of \(p(x, y)\) are at \((x1, y1)\) and \((x2, y2)\). The conditional distributions \(p(x|y=y_1)\) and \(p(x|y=y_2)\) are shown overlaid on the main plot.</p></figcaption></figure><p>Consider the figure above. Think of \(p(x)\) as being a simplified 1-D version of the underlying distribution of a glyph dataset, and \(p(y)\) as being the corresponding distribution of a text dataset. These are the <em>marginal distributions</em> of the joint distribution, obtained by integrating the joint over all possible values of conditioning variable as mentioned <a href=#forward-diffusion-or-noising>above</a>. We can obtain a <em>conditioned distribution</em> \(p(x|y=y_1)\) by taking a slice through the <em>joint distribution</em> \(p(x,y)\) at a given value of \(y\).</p><p>Let&rsquo;s give an example. The Chinese character &ldquo;木&rdquo; means &ldquo;wood&rdquo;, while &ldquo;火&rdquo; means &ldquo;fire&rdquo;. Assume that we&rsquo;ve converted these characters and words to 1-D representations. &ldquo;木&rdquo; lies at \(x = x_1\) while &ldquo;火&rdquo; lies at \(x = x_2\). &ldquo;Wood&rdquo; lies at \(y = y_1\) while &ldquo;fire&rdquo; lies at \(y = y_2\). In \(p(x)\), &ldquo;木&rdquo; and &ldquo;火&rdquo; are equally probable. However, if we condition \(p(x)\) on \(p(y)\), the conditional distributions \(p(x|y)\) clearly distinguish the values of &ldquo;木&rdquo; and &ldquo;火&rdquo; based on the conditioning values of &ldquo;wood&rdquo; or &ldquo;fire&rdquo;. This is the core idea behind how conditioning guides text-to-image diffusion models: text conditioning adjusts the underlying distribution of image dataset to favour regions associated with the text.</p><p>In practice, we can convert our text conditioning information (the character definitions) into a numerical form using <em>large language model (LLM) embeddings</em> that can be injected into the noise prediction model during training.</p><h3 id=embedding-text-with-an-llm>Embedding text with an LLM<a hidden class=anchor aria-hidden=true href=#embedding-text-with-an-llm>#</a></h3><p>Let&rsquo;s take the example of the glyffuser. Our conditioning information is in the form of <a href=https://github.com/unicode-org/unihan-database/blob/main/kDefinition.txt>English text definitions</a>. We have two requirements: 1. As previously touched upon, ML models prefer fixed-length vectors as input, so we&rsquo;d like a way to convert our text into this format. 2. This numerical representation of our text must understand the context - if we have the words &ldquo;lithium&rdquo; and &ldquo;element&rdquo; nearby, the meaning of &ldquo;element&rdquo; should be understood as &ldquo;chemical element&rdquo; rather than &ldquo;heating element&rdquo;. Both of these requirements can be met by using a pre-trained LLM.</p><p>The diagram below shows how a LLM converts text into fixed-length vectors. The text is first <em>tokenized</em> (LLMs break text into <em>tokens</em>, small chunks of characters, as their basic unit of interaction). Each token is converted into a base <em>embedding</em>, which is a fixed-length vector of the size of the LLM input. These vectors are then passed through the pre-trained LLM (here we use the <em>encoder</em> portion of Google&rsquo;s T5 model), where they are imbued with additional contextual meaning. We end up with a array of <em>n</em> vectors of the same length <em>d</em>, i.e. a (<em>n, d</em>) sized tensor.</p><figure class=align-center><img loading=lazy src=/LLM_embedding.png#center alt="We can convert text to a numerical embedding imbued with contextual meaning using a pre-trained LLM."><figcaption><p>We can convert text to a numerical embedding imbued with contextual meaning using a pre-trained LLM.</p></figcaption></figure><h3 id=training-the-diffusion-model-with-text-conditioning>Training the diffusion model with text conditioning<a hidden class=anchor aria-hidden=true href=#training-the-diffusion-model-with-text-conditioning>#</a></h3><p>The exact method that this embedding vector is injected into the model can vary. In Google&rsquo;s <a href=https://arxiv.org/pdf/2205.11487>Imagen</a> model, for example, the embedding tensor is pooled (combined into a single vector in the embedding dimension) and added into the data as it passes through the noise prediction model; it is also included using in a different way using <em>cross-attention</em> (a method of learning contextual information between sequences of tokens, most famously used in the <em>transformer</em> models that form the basis of LLMs like ChatGPT).</p><figure class=align-center><img loading=lazy src=/text_conditioning.png#center alt="Conditioning information can be added via multiple different methods but the training loss remains the same."><figcaption><p>Conditioning information can be added <em>via</em> multiple different methods but the training loss remains the same.</p></figcaption></figure><p>In the glyffuser, we only use cross-attention to introduce this conditioning information. While a significant architectural change is required to introduce this additional information into the model, the loss function for our noise prediction model remains exactly the same.</p><h3 id=testing-the-conditioned-diffusion-model>Testing the conditioned diffusion model<a hidden class=anchor aria-hidden=true href=#testing-the-conditioned-diffusion-model>#</a></h3><p>Let&rsquo;s do a simple test of the fully trained conditioned diffusion model. In the figure below, we try to denoise in a single step with the text prompt &ldquo;Gold&rdquo;. As touched upon in our <a href=#dataset-visualization>interactive UMAP</a>, Chinese characters often contain components known as <em>radicals</em> which can convey sound (phonetic radicals) or meaning (semantic radicals). A common semantic radical is derived from the character meaning &ldquo;gold&rdquo;, &ldquo;金&rdquo;, and is used in characters that are in some broad sense associated with gold or metals.</p><figure class=align-center><img loading=lazy src=/conditioned_denoising.png#center alt="Even with a single sampling step, conditioning guides denoising towards the relevant regions of the probability distribution."><figcaption><p>Even with a single sampling step, conditioning guides denoising towards the relevant regions of the probability distribution.</p></figcaption></figure><p>The figure shows that even though a single step is insufficient to approximate the denoising trajectory very well, we have activated the &ldquo;金&rdquo; radical. This indicates that the text prompt is very effectively guiding our sampling towards a region of the glyph probability distribution related to the meaning of the prompt. The animation below shows a 120 step denoising sequence for the same prompt.</p><center><video width=80% autoplay loop muted playsinline>
<source src=/cond_denoising_gold.mp4 type=video/mp4>Your browser does not support the video tag.</video></center><h3 id=takeaway-2>Takeaway<a hidden class=anchor aria-hidden=true href=#takeaway-2>#</a></h3><p>Conditioning enables us to sample meaningful outputs from diffusion models.</p><h2 id=further-remarks>Further remarks<a hidden class=anchor aria-hidden=true href=#further-remarks>#</a></h2><p>I found that with the help of tutorials and existing libraries, it was possible to implement a working diffusion model despite not having a full understanding of what was going on under the hood. I think this is a good way to start learning and highly recommend Hugging Face&rsquo;s <a href=https://huggingface.co/docs/diffusers/tutorials/basic_training>tutorial</a> on training a simple diffusion model using their <code>diffusers</code> Python library (which now includes my small <a href=https://github.com/huggingface/diffusers/pull/8223>bugfix</a>!).</p><p>For further reading, I direct you to the various articles I linked in the <a href=#intro>introduction</a> and throughout this post.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yue-here.com/>Yue Wu</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>